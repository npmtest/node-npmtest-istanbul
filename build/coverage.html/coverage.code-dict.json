{"/home/travis/build/npmtest/node-npmtest-istanbul/test.js":"/* istanbul instrument in package npmtest_istanbul */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-istanbul/lib.npmtest_istanbul.js":"/* istanbul instrument in package npmtest_istanbul */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_istanbul = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_istanbul = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-istanbul/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-istanbul && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_istanbul */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_istanbul\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_istanbul.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_istanbul.rollup.js'] =\n            local.assetsDict['/assets.npmtest_istanbul.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_istanbul.__dirname +\n                    '/lib.npmtest_istanbul.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/index.js":"/*\nCopyright (c) 2012, Yahoo! Inc.  All rights reserved.\nCopyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n*/\n\n/*jslint nomen: true */\nvar path = require('path'),\n    Store = require('./lib/store'),\n    Report = require('./lib/report'),\n    meta = require('./lib/util/meta');\n\n//register our standard plugins\nrequire('./lib/register-plugins');\n\n/**\n * the top-level API for `istanbul`. provides access to the key libraries in\n * istanbul so you can write your own tools using `istanbul` as a library.\n *\n * Usage\n * -----\n *\n *      var istanbul = require('istanbul');\n *\n *\n * @class Istanbul\n * @static\n * @module main\n * @main main\n */\n\nmodule.exports = {\n    /**\n     * the Instrumenter class.\n     * @property Instrumenter\n     * @type Instrumenter\n     * @static\n     */\n    Instrumenter: require('./lib/instrumenter'),\n    /**\n     * the Store class.\n     * @property  Store\n     * @type Store\n     * @static\n     */\n    Store: Store,\n    /**\n     * the Collector class\n     * @property  Collector\n     * @type Collector\n     * @static\n     */\n    Collector: require('./lib/collector'),\n    /**\n     * the hook module\n     * @property hook\n     * @type Hook\n     * @static\n     */\n    hook: require('./lib/hook'),\n    /**\n     * the Report class\n     * @property Report\n     * @type Report\n     * @static\n     */\n    Report: Report,\n    /**\n     * the config module\n     * @property config\n     * @type Config\n     * @static\n     */\n    config: require('./lib/config'),\n    /**\n     * the Reporter class\n     * @property Reporter\n     * @type Reporter\n     * @static\n     */\n    Reporter: require('./lib/reporter'),\n    /**\n     * utility for processing coverage objects\n     * @property utils\n     * @type ObjectUtils\n     * @static\n     */\n    utils: require('./lib/object-utils'),\n    /**\n     * asynchronously returns a function that can match filesystem paths.\n     * The function returned in the callback may be passed directly as a `matcher`\n     * to the functions in the `hook` module.\n     *\n     * When no options are passed, the match function is one that matches all JS\n     * files under the current working directory except ones under `node_modules`\n     *\n     * Match patterns are `ant`-style patterns processed using the `glob` library.\n     * Examples not provided due to limitations in putting asterisks inside\n     * jsdoc comments. Please refer to tests under `test/other/test-matcher.js`\n     * for examples.\n     *\n     * @method matcherFor\n     * @static\n     * @param {Object} options Optional. Lookup options.\n     * @param {String} [options.root] the root of the filesystem tree under\n     *     which to match files. Defaults to `process.cwd()`\n     * @param {Array} [options.includes] an array of include patterns to match.\n     *     Defaults to all JS files under the root.\n     * @param {Array} [options.excludes] and array of exclude patterns. File paths\n     *     matching these patterns will be excluded by the returned matcher.\n     *     Defaults to files under `node_modules` found anywhere under root.\n     * @param {Function(err, matchFunction)} callback  The callback that is\n     *      called with two arguments. The first is an `Error` object in case\n     *      of errors or a falsy value if there were no errors. The second\n     *      is a function that may be use as a matcher.\n     */\n    matcherFor: require('./lib/util/file-matcher').matcherFor,\n    /**\n     * the version of the library\n     * @property VERSION\n     * @type String\n     * @static\n     */\n    VERSION: meta.VERSION,\n    /**\n     * the abstract Writer class\n     * @property Writer\n     * @type Writer\n     * @static\n     */\n    Writer: require('./lib/util/writer').Writer,\n    /**\n     * the abstract ContentWriter class\n     * @property ContentWriter\n     * @type ContentWriter\n     * @static\n     */\n    ContentWriter: require('./lib/util/writer').ContentWriter,\n    /**\n     * the concrete FileWriter class\n     * @property FileWriter\n     * @type FileWriter\n     * @static\n     */\n    FileWriter: require('./lib/util/file-writer'),\n    //undocumented\n    _yuiLoadHook: require('./lib/util/yui-load-hook'),\n    //undocumented\n    TreeSummarizer: require('./lib/util/tree-summarizer'),\n    //undocumented\n    assetsDir: path.resolve(__dirname, 'lib', 'assets')\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/store/index.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar Factory = require('../util/factory'),\n    factory = new Factory('store', __dirname, false);\n/**\n * An abstraction for keeping track of content against some keys (e.g.\n * original source, instrumented source, coverage objects against file names).\n * This class is both the base class as well as a factory for `Store` implementations.\n *\n * Usage\n * -----\n *\n *      var Store = require('istanbul').Store,\n *          store = Store.create('memory');\n *\n *      //basic use\n *      store.set('foo', 'foo-content');\n *      var content = store.get('foo');\n *\n *      //keys and values\n *      store.keys().forEach(function (key) {\n *          console.log(key + ':\\n' + store.get(key);\n *      });\n *      if (store.hasKey('bar') { console.log(store.get('bar'); }\n *\n *\n *      //syntactic sugar\n *      store.setObject('foo', { foo: true });\n *      console.log(store.getObject('foo').foo);\n *\n *      store.dispose();\n *\n * @class Store\n * @constructor\n * @module store\n * @param {Object} options Optional. The options supported by a specific store implementation.\n * @main store\n */\nfunction Store(/* options */) {}\n\n//add register, create, mix, loadAll, getStoreList as class methods\nfactory.bindClassMethods(Store);\n\n/**\n * registers a new store implementation.\n * @method register\n * @static\n * @param {Function} constructor the constructor function for the store. This function must have a\n *  `TYPE` property of type String, that will be used in `Store.create()`\n */\n/**\n * returns a store implementation of the specified type.\n * @method create\n * @static\n * @param {String} type the type of store to create\n * @param {Object} opts Optional. Options specific to the store implementation\n * @return {Store} a new store of the specified type\n */\n\nStore.prototype = {\n    /**\n     * sets some content associated with a specific key. The manner in which\n     * duplicate keys are handled for multiple `set()` calls with the same\n     * key is implementation-specific.\n     *\n     * @method set\n     * @param {String} key the key for the content\n     * @param {String} contents the contents for the key\n     */\n    set: function (/* key, contents */) { throw new Error(\"set: must be overridden\"); },\n    /**\n     * returns the content associated to a specific key or throws if the key\n     * was not `set`\n     * @method get\n     * @param {String} key the key for which to get the content\n     * @return {String} the content for the specified key\n     */\n    get: function (/* key */) { throw new Error(\"get: must be overridden\"); },\n    /**\n     * returns a list of all known keys\n     * @method keys\n     * @return {Array} an array of seen keys\n     */\n    keys: function () { throw new Error(\"keys: must be overridden\"); },\n    /**\n     * returns true if the key is one for which a `get()` call would work.\n     * @method hasKey\n     * @param {String} key\n     * @return true if the key is valid for this store, false otherwise\n     */\n    hasKey: function (/* key */) { throw new Error(\"hasKey: must be overridden\"); },\n    /**\n     * lifecycle method to dispose temporary resources associated with the store\n     * @method dispose\n     */\n    dispose: function () {},\n    /**\n     * sugar method to return an object associated with a specific key. Throws\n     * if the content set against the key was not a valid JSON string.\n     * @method getObject\n     * @param {String} key the key for which to return the associated object\n     * @return {Object} the object corresponding to the key\n     */\n    getObject: function (key) {\n        return JSON.parse(this.get(key));\n    },\n    /**\n     * sugar method to set an object against a specific key.\n     * @method setObject\n     * @param {String} key the key for the object\n     * @param {Object} object the object to be stored\n     */\n    setObject: function (key, object) {\n        return this.set(key, JSON.stringify(object));\n    }\n};\n\nmodule.exports = Store;\n\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/util/factory.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar util = require('util'),\n    path = require('path'),\n    fs = require('fs'),\n    abbrev = require('abbrev');\n\nfunction Factory(kind, dir, allowAbbreviations) {\n    this.kind = kind;\n    this.dir = dir;\n    this.allowAbbreviations = allowAbbreviations;\n    this.classMap = {};\n    this.abbreviations = null;\n}\n\nFactory.prototype = {\n\n    knownTypes: function () {\n        var keys = Object.keys(this.classMap);\n        keys.sort();\n        return keys;\n    },\n\n    resolve: function (abbreviatedType) {\n        if (!this.abbreviations) {\n            this.abbreviations = abbrev(this.knownTypes());\n        }\n        return this.abbreviations[abbreviatedType];\n    },\n\n    register: function (constructor) {\n        var type = constructor.TYPE;\n        if (!type) { throw new Error('Could not register ' + this.kind + ' constructor [no TYPE property]: ' + util.inspect(constructor)); }\n        this.classMap[type] = constructor;\n        this.abbreviations = null;\n    },\n\n    create: function (type, opts) {\n        var allowAbbrev = this.allowAbbreviations,\n            realType = allowAbbrev ? this.resolve(type) : type,\n            Cons;\n\n        Cons = realType ? this.classMap[realType] : null;\n        if (!Cons) { throw new Error('Invalid ' + this.kind + ' [' + type + '], allowed values are ' + this.knownTypes().join(', ')); }\n        return new Cons(opts);\n    },\n\n    loadStandard: function (dir) {\n        var that = this;\n        fs.readdirSync(dir).forEach(function (file) {\n            if (file !== 'index.js' && file.indexOf('.js') === file.length - 3) {\n                try {\n                    that.register(require(path.resolve(dir, file)));\n                } catch (ex) {\n                    console.error(ex.message);\n                    console.error(ex.stack);\n                    throw new Error('Could not register ' + that.kind + ' from file ' + file);\n                }\n            }\n        });\n    },\n\n    bindClassMethods: function (Cons) {\n        var tmpKind = this.kind.charAt(0).toUpperCase() + this.kind.substring(1), //ucfirst\n            allowAbbrev = this.allowAbbreviations;\n\n        Cons.mix = Factory.mix;\n        Cons.register = this.register.bind(this);\n        Cons.create = this.create.bind(this);\n        Cons.loadAll = this.loadStandard.bind(this, this.dir);\n        Cons['get' + tmpKind + 'List'] = this.knownTypes.bind(this);\n        if (allowAbbrev) {\n            Cons['resolve' + tmpKind + 'Name'] = this.resolve.bind(this);\n        }\n    }\n};\n\nFactory.mix = function (cons, proto) {\n    Object.keys(proto).forEach(function (key) {\n        cons.prototype[key] = proto[key];\n    });\n};\n\nmodule.exports = Factory;\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/index.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar util = require('util'),\n    EventEmitter = require('events').EventEmitter,\n    Factory = require('../util/factory'),\n    factory = new Factory('report', __dirname, false);\n/**\n * An abstraction for producing coverage reports.\n * This class is both the base class as well as a factory for `Report` implementations.\n * All reports are event emitters and are expected to emit a `done` event when\n * the report writing is complete.\n *\n * See also the `Reporter` class for easily producing multiple coverage reports\n * with a single call.\n *\n * Usage\n * -----\n *\n *      var Report = require('istanbul').Report,\n *          report = Report.create('html'),\n *          collector = new require('istanbul').Collector;\n *\n *      collector.add(coverageObject);\n *      report.on('done', function () { console.log('done'); });\n *      report.writeReport(collector);\n *\n * @class Report\n * @module report\n * @main report\n * @constructor\n * @protected\n * @param {Object} options Optional. The options supported by a specific store implementation.\n */\nfunction Report(/* options */) {\n    EventEmitter.call(this);\n}\n\nutil.inherits(Report, EventEmitter);\n\n//add register, create, mix, loadAll, getReportList as class methods\nfactory.bindClassMethods(Report);\n\n/**\n * registers a new report implementation.\n * @method register\n * @static\n * @param {Function} constructor the constructor function for the report. This function must have a\n *  `TYPE` property of type String, that will be used in `Report.create()`\n */\n/**\n * returns a report implementation of the specified type.\n * @method create\n * @static\n * @param {String} type the type of report to create\n * @param {Object} opts Optional. Options specific to the report implementation\n * @return {Report} a new store of the specified type\n */\n/**\n * returns the list of available reports as an array of strings\n * @method getReportList\n * @static\n * @return an array of supported report formats\n */\n\nvar proto = {\n    /**\n     * returns a one-line summary of the report\n     * @method synopsis\n     * @return {String} a description of what the report is about\n     */\n    synopsis: function () {\n        throw new Error('synopsis must be overridden');\n    },\n    /**\n     * returns a config object that has override-able keys settable via config\n     * @method getDefaultConfig\n     * @return {Object|null} an object representing keys that can be overridden via\n     *  the istanbul configuration where the values are the defaults used when\n     *  not specified. A null return implies no config attributes\n     */\n    getDefaultConfig: function () {\n        return null;\n    },\n    /**\n     * writes the report for a set of coverage objects added to a collector.\n     * @method writeReport\n     * @param {Collector} collector the collector for getting the set of files and coverage\n     * @param {Boolean} sync true if reports must be written synchronously, false if they can be written using asynchronous means (e.g. stream.write)\n     */\n    writeReport: function (/* collector, sync */) {\n        throw new Error('writeReport: must be overridden');\n    }\n};\n\nObject.keys(proto).forEach(function (k) {\n    Report.prototype[k] = proto[k];\n});\n\nmodule.exports = Report;\n\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/util/meta.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar path = require('path'),\n    fs = require('fs'),\n    pkg = JSON.parse(fs.readFileSync(path.resolve(__dirname, '..', '..', 'package.json'), 'utf8'));\n\nmodule.exports = {\n    NAME: pkg.name,\n    VERSION: pkg.version\n};\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/register-plugins.js":"\n/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar Store = require('./store'),\n    Report = require('./report'),\n    Command = require('./command');\n\nStore.loadAll();\nReport.loadAll();\nCommand.loadAll();\n\n\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/command/index.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar Factory = require('../util/factory'),\n    factory = new Factory('command', __dirname, true);\n\nfunction Command() {}\n// add register, create, mix, loadAll, getCommandList, resolveCommandName to the Command object\nfactory.bindClassMethods(Command);\n\nCommand.prototype = {\n    toolName: function () {\n        return require('../util/meta').NAME;\n    },\n\n    type: function () {\n        return this.constructor.TYPE;\n    },\n    synopsis: /* istanbul ignore next: base method */ function () {\n        return \"the developer has not written a one-line summary of the \" + this.type() + \" command\";\n    },\n    usage: /* istanbul ignore next: base method */ function () {\n        console.error(\"the developer has not provided a usage for the \" + this.type() + \" command\");\n    },\n    run: /* istanbul ignore next: abstract method */ function (args, callback) {\n        return callback(new Error(\"run: must be overridden for the \" + this.type() + \" command\"));\n    }\n};\n\nmodule.exports = Command;\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/store/fslookup.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar util = require('util'),\n    fs = require('fs'),\n    Store = require('./index');\n\n/**\n * a `Store` implementation that doesn't actually store anything. It assumes that keys\n * are absolute file paths, and contents are contents of those files.\n * Thus, `set` for this store is no-op, `get` returns the\n * contents of the filename that the key represents, `hasKey` returns true if the key\n * supplied is a valid file path and `keys` always returns an empty array.\n *\n * Usage\n * -----\n *\n *      var store = require('istanbul').Store.create('fslookup');\n *\n *\n * @class LookupStore\n * @extends Store\n * @module store\n * @constructor\n */\nfunction LookupStore(opts) {\n    Store.call(this, opts);\n}\n\nLookupStore.TYPE = 'fslookup';\nutil.inherits(LookupStore, Store);\n\nStore.mix(LookupStore, {\n    keys: function () {\n        return [];\n    },\n    get: function (key) {\n        return fs.readFileSync(key, 'utf8');\n    },\n    hasKey: function (key) {\n        var stats;\n        try {\n            stats = fs.statSync(key);\n            return stats.isFile();\n        } catch (ex) {\n            return false;\n        }\n    },\n    set: function (key /*, contents */) {\n        if (!this.hasKey(key)) {\n            throw new Error('Attempt to set contents for non-existent file [' + key + '] on a fslookup store');\n        }\n        return key;\n    }\n});\n\n\nmodule.exports = LookupStore;\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/store/memory.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar util = require('util'),\n    Store = require('./index');\n\n/**\n * a `Store` implementation using an in-memory object.\n *\n * Usage\n * -----\n *\n *      var store = require('istanbul').Store.create('memory');\n *\n *\n * @class MemoryStore\n * @extends Store\n * @module store\n * @constructor\n */\nfunction MemoryStore() {\n    Store.call(this);\n    this.map = {};\n}\n\nMemoryStore.TYPE = 'memory';\nutil.inherits(MemoryStore, Store);\n\nStore.mix(MemoryStore, {\n    set: function (key, contents) {\n        this.map[key] = contents;\n    },\n\n    get: function (key) {\n        if (!this.hasKey(key)) {\n            throw new Error('Unable to find entry for [' + key + ']');\n        }\n        return this.map[key];\n    },\n\n    hasKey: function (key) {\n        return this.map.hasOwnProperty(key);\n    },\n\n    keys: function () {\n        return Object.keys(this.map);\n    },\n\n    dispose: function () {\n        this.map = {};\n    }\n});\n\nmodule.exports = MemoryStore;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/store/tmp.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar util = require('util'),\n    path = require('path'),\n    os = require('os'),\n    fs = require('fs'),\n    mkdirp = require('mkdirp'),\n    Store = require('./index');\n\nfunction makeTempDir() {\n    var dir = path.join(os.tmpdir ? os.tmpdir() : /* istanbul ignore next */ (process.env.TMPDIR || '/tmp'), 'ts' + new Date().getTime());\n    mkdirp.sync(dir);\n    return dir;\n}\n/**\n * a `Store` implementation using temporary files.\n *\n * Usage\n * -----\n *\n *      var store = require('istanbul').Store.create('tmp');\n *\n *\n * @class TmpStore\n * @extends Store\n * @module store\n * @param {Object} opts Optional.\n * @param {String} [opts.tmp] a pre-existing directory to use as the `tmp` directory. When not specified, a random directory\n *      is created under `os.tmpdir()`\n * @constructor\n */\nfunction TmpStore(opts) {\n    opts = opts || {};\n    this.tmp = opts.tmp || makeTempDir();\n    this.map = {};\n    this.seq = 0;\n    this.prefix = 't' + new Date().getTime() + '-';\n}\n\nTmpStore.TYPE = 'tmp';\nutil.inherits(TmpStore, Store);\n\nStore.mix(TmpStore, {\n    generateTmpFileName: function () {\n        this.seq += 1;\n        return path.join(this.tmp, this.prefix + this.seq + '.tmp');\n    },\n\n    set: function (key, contents) {\n        var tmpFile = this.generateTmpFileName();\n        fs.writeFileSync(tmpFile, contents, 'utf8');\n        this.map[key] = tmpFile;\n    },\n\n    get: function (key) {\n        var tmpFile = this.map[key];\n        if (!tmpFile) { throw new Error('Unable to find tmp entry for [' + tmpFile + ']'); }\n        return fs.readFileSync(tmpFile, 'utf8');\n    },\n\n    hasKey: function (key) {\n        return !!this.map[key];\n    },\n\n    keys: function () {\n        return Object.keys(this.map);\n    },\n\n    dispose: function () {\n        var map = this.map;\n        Object.keys(map).forEach(function (key) {\n            fs.unlinkSync(map[key]);\n        });\n        this.map = {};\n    }\n});\n\nmodule.exports = TmpStore;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/clover.js":"var path = require('path'),\n    util = require('util'),\n    Report = require('./index'),\n    FileWriter = require('../util/file-writer'),\n    TreeSummarizer = require('../util/tree-summarizer'),\n    utils = require('../object-utils');\n\n/**\n * a `Report` implementation that produces a clover-style XML file.\n *\n * Usage\n * -----\n *\n *      var report = require('istanbul').Report.create('clover');\n *\n * @class CloverReport\n * @module report\n * @extends Report\n * @constructor\n * @param {Object} opts optional\n * @param {String} [opts.dir] the directory in which to the clover.xml will be written\n * @param {String} [opts.file] the file name, defaulted to config attribute or 'clover.xml'\n */\nfunction CloverReport(opts) {\n    Report.call(this);\n    opts = opts || {};\n    this.projectRoot = process.cwd();\n    this.dir = opts.dir || this.projectRoot;\n    this.file = opts.file || this.getDefaultConfig().file;\n    this.opts = opts;\n}\n\nCloverReport.TYPE = 'clover';\nutil.inherits(CloverReport, Report);\n\nfunction asJavaPackage(node) {\n    return node.displayShortName().\n        replace(/\\//g, '.').\n        replace(/\\\\/g, '.').\n        replace(/\\.$/, '');\n}\n\nfunction asClassName(node) {\n    /*jslint regexp: true */\n    return node.fullPath().replace(/.*[\\\\\\/]/, '');\n}\n\nfunction quote(thing) {\n    return '\"' + thing + '\"';\n}\n\nfunction attr(n, v) {\n    return ' ' + n + '=' + quote(v) + ' ';\n}\n\nfunction branchCoverageByLine(fileCoverage) {\n    var branchMap = fileCoverage.branchMap,\n        branches = fileCoverage.b,\n        ret = {};\n    Object.keys(branchMap).forEach(function (k) {\n        var line = branchMap[k].line,\n            branchData = branches[k];\n        ret[line] = ret[line] || [];\n        ret[line].push.apply(ret[line], branchData);\n    });\n    Object.keys(ret).forEach(function (k) {\n        var dataArray = ret[k],\n            covered = dataArray.filter(function (item) { return item > 0; }),\n            coverage = covered.length / dataArray.length * 100;\n        ret[k] = { covered: covered.length, total: dataArray.length, coverage: coverage };\n    });\n    return ret;\n}\n\nfunction addClassStats(node, fileCoverage, writer) {\n    fileCoverage = utils.incrementIgnoredTotals(fileCoverage);\n\n    var metrics = node.metrics,\n        branchByLine = branchCoverageByLine(fileCoverage),\n        fnMap,\n        lines;\n\n    writer.println('\\t\\t\\t<file' +\n        attr('name', asClassName(node)) +\n        attr('path', node.fullPath()) +\n        '>');\n\n    writer.println('\\t\\t\\t\\t<metrics' +\n        attr('statements', metrics.lines.total) +\n        attr('coveredstatements', metrics.lines.covered) +\n        attr('conditionals', metrics.branches.total) +\n        attr('coveredconditionals', metrics.branches.covered) +\n        attr('methods', metrics.functions.total) +\n        attr('coveredmethods', metrics.functions.covered) +\n        '/>');\n\n    fnMap = fileCoverage.fnMap;\n    lines = fileCoverage.l;\n    Object.keys(lines).forEach(function (k) {\n        var str = '\\t\\t\\t\\t<line' +\n            attr('num', k) +\n            attr('count', lines[k]),\n            branchDetail = branchByLine[k];\n\n        if (!branchDetail) {\n            str += ' type=\"stmt\" ';\n        } else {\n                str += ' type=\"cond\" ' +\n                attr('truecount', branchDetail.covered) +\n                attr('falsecount', (branchDetail.total - branchDetail.covered));\n        }\n        writer.println(str + '/>');\n    });\n\n    writer.println('\\t\\t\\t</file>');\n}\n\nfunction walk(node, collector, writer, level, projectRoot) {\n    var metrics,\n        totalFiles = 0,\n        totalPackages = 0,\n        totalLines = 0,\n        tempLines = 0;\n    if (level === 0) {\n        metrics = node.metrics;\n        writer.println('<?xml version=\"1.0\" encoding=\"UTF-8\"?>');\n        writer.println('<coverage' +\n            attr('generated', Date.now()) +\n            'clover=\"3.2.0\">');\n\n        writer.println('\\t<project' +\n            attr('timestamp', Date.now()) +\n            attr('name', 'All Files') +\n            '>');\n\n        node.children.filter(function (child) { return child.kind === 'dir'; }).\n            forEach(function (child) {\n                totalPackages += 1;\n                child.children.filter(function (child) { return child.kind !== 'dir'; }).\n                    forEach(function (child) {\n                        Object.keys(collector.fileCoverageFor(child.fullPath()).l).forEach(function (k){\n                            tempLines = k;\n                        });\n                        totalLines += Number(tempLines);\n                        totalFiles += 1;\n                });\n        });\n\n        writer.println('\\t\\t<metrics' +\n            attr('statements', metrics.lines.total) +\n            attr('coveredstatements', metrics.lines.covered) +\n            attr('conditionals', metrics.branches.total) +\n            attr('coveredconditionals', metrics.branches.covered) +\n            attr('methods', metrics.functions.total) +\n            attr('coveredmethods', metrics.functions.covered) +\n            attr('elements', metrics.lines.total + metrics.branches.total + metrics.functions.total) +\n            attr('coveredelements', metrics.lines.covered + metrics.branches.covered + metrics.functions.covered) +\n            attr('complexity', 0) +\n            attr('packages', totalPackages) +\n            attr('files', totalFiles) +\n            attr('classes', totalFiles) +\n            attr('loc', totalLines) +\n            attr('ncloc', totalLines) +\n            '/>');\n    }\n    if (node.packageMetrics) {\n        metrics = node.packageMetrics;\n        writer.println('\\t\\t<package' +\n            attr('name', asJavaPackage(node)) +\n            '>');\n\n        writer.println('\\t\\t\\t<metrics' +\n            attr('statements', metrics.lines.total) +\n            attr('coveredstatements', metrics.lines.covered) +\n            attr('conditionals', metrics.branches.total) +\n            attr('coveredconditionals', metrics.branches.covered) +\n            attr('methods', metrics.functions.total) +\n            attr('coveredmethods', metrics.functions.covered) +\n            '/>');\n\n        node.children.filter(function (child) { return child.kind !== 'dir'; }).\n            forEach(function (child) {\n                addClassStats(child, collector.fileCoverageFor(child.fullPath()), writer);\n            });\n        writer.println('\\t\\t</package>');\n    }\n    node.children.filter(function (child) { return child.kind === 'dir'; }).\n        forEach(function (child) {\n            walk(child, collector, writer, level + 1, projectRoot);\n        });\n\n    if (level === 0) {\n        writer.println('\\t</project>');\n        writer.println('</coverage>');\n    }\n}\n\nReport.mix(CloverReport, {\n    synopsis: function () {\n        return 'XML coverage report that can be consumed by the clover tool';\n    },\n    getDefaultConfig: function () {\n        return { file: 'clover.xml' };\n    },\n    writeReport: function (collector, sync) {\n        var summarizer = new TreeSummarizer(),\n            outputFile = path.join(this.dir, this.file),\n            writer = this.opts.writer || new FileWriter(sync),\n            projectRoot = this.projectRoot,\n            that = this,\n            tree,\n            root;\n\n        collector.files().forEach(function (key) {\n            summarizer.addFileCoverageSummary(key, utils.summarizeFileCoverage(collector.fileCoverageFor(key)));\n        });\n        tree = summarizer.getTreeSummary();\n        root = tree.root;\n        writer.on('done', function () { that.emit('done'); });\n        writer.writeFile(outputFile, function (contentWriter) {\n            walk(root, collector, contentWriter, 0, projectRoot);\n            writer.done();\n        });\n    }\n});\n\nmodule.exports = CloverReport;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/util/file-writer.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = require('path'),\n    util = require('util'),\n    fs = require('fs'),\n    async = require('async'),\n    mkdirp = require('mkdirp'),\n    writer = require('./writer'),\n    Writer = writer.Writer,\n    ContentWriter = writer.ContentWriter;\n\nfunction extend(cons, proto) {\n    Object.keys(proto).forEach(function (k) {\n        cons.prototype[k] = proto[k];\n    });\n}\n\nfunction BufferedContentWriter() {\n    ContentWriter.call(this);\n    this.content = '';\n}\nutil.inherits(BufferedContentWriter, ContentWriter);\n\nextend(BufferedContentWriter, {\n    write: function (str) {\n        this.content += str;\n    },\n    getContent: function () {\n        return this.content;\n    }\n});\n\nfunction StreamContentWriter(stream) {\n    ContentWriter.call(this);\n    this.stream = stream;\n}\nutil.inherits(StreamContentWriter, ContentWriter);\n\nextend(StreamContentWriter, {\n    write: function (str) {\n        this.stream.write(str);\n    }\n});\n\nfunction SyncFileWriter() {\n    Writer.call(this);\n}\nutil.inherits(SyncFileWriter, Writer);\n\nextend(SyncFileWriter, {\n    writeFile: function (file, callback) {\n        mkdirp.sync(path.dirname(file));\n        var cw = new BufferedContentWriter();\n        callback(cw);\n        fs.writeFileSync(file, cw.getContent(), 'utf8');\n    },\n    done: function () {\n        this.emit('done'); //everything already done\n    }\n});\n\nfunction AsyncFileWriter() {\n    this.queue = async.queue(this.processFile.bind(this), 20);\n    this.openFileMap = {};\n}\n\nutil.inherits(AsyncFileWriter, Writer);\n\nextend(AsyncFileWriter, {\n    writeFile: function (file, callback) {\n        this.openFileMap[file] = true;\n        this.queue.push({ file: file, callback: callback });\n    },\n    processFile: function (task, cb) {\n        var file = task.file,\n            userCallback = task.callback,\n            that = this,\n            stream,\n            contentWriter;\n\n        mkdirp.sync(path.dirname(file));\n        stream = fs.createWriteStream(file);\n        stream.on('close', function () {\n            delete that.openFileMap[file];\n            cb();\n            that.checkDone();\n        });\n        stream.on('error', function (err) { that.emit('error', err); });\n        contentWriter = new StreamContentWriter(stream);\n        userCallback(contentWriter);\n        stream.end();\n    },\n    done: function () {\n        this.doneCalled = true;\n        this.checkDone();\n    },\n    checkDone: function () {\n        if (!this.doneCalled) { return; }\n        if (Object.keys(this.openFileMap).length === 0) {\n            this.emit('done');\n        }\n    }\n});\n/**\n * a concrete writer implementation that can write files synchronously or\n * asynchronously based on the constructor argument passed to it.\n *\n * Usage\n * -----\n *\n *      var sync = true,\n *          fileWriter = new require('istanbul').FileWriter(sync);\n *\n *      fileWriter.on('done', function () { console.log('done'); });\n *      fileWriter.copyFile('/foo/bar.jpg', '/baz/bar.jpg');\n *      fileWriter.writeFile('/foo/index.html', function (contentWriter) {\n *          contentWriter.println('<html>');\n *          contentWriter.println('</html>');\n *      });\n *      fileWriter.done(); // will emit the `done` event when all files are written\n *\n * @class FileWriter\n * @extends Writer\n * @module io\n * @param sync\n * @constructor\n */\nfunction FileWriter(sync) {\n    Writer.call(this);\n    var that = this;\n    this.delegate = sync ? new SyncFileWriter() : new AsyncFileWriter();\n    this.delegate.on('error', function (err) { that.emit('error', err); });\n    this.delegate.on('done', function () { that.emit('done'); });\n}\n\nutil.inherits(FileWriter, Writer);\n\nextend(FileWriter, {\n    copyFile: function (source, dest) {\n        mkdirp.sync(path.dirname(dest));\n        fs.writeFileSync(dest, fs.readFileSync(source));\n    },\n    writeFile: function (file, callback) {\n        this.delegate.writeFile(file, callback);\n    },\n    done: function () {\n        this.delegate.done();\n    }\n});\n\nmodule.exports = FileWriter;","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/util/writer.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar util = require('util'),\n    EventEmitter = require('events').EventEmitter;\n\nfunction extend(cons, proto) {\n    Object.keys(proto).forEach(function (k) {\n        cons.prototype[k] = proto[k];\n    });\n}\n\n/**\n * abstract interfaces for writing content\n * @class ContentWriter\n * @module io\n * @main io\n * @constructor\n */\n//abstract interface for writing content\nfunction ContentWriter() {\n}\n\nContentWriter.prototype = {\n    /**\n     * writes the specified string as-is\n     * @method write\n     * @param {String} str the string to write\n     */\n    write: /* istanbul ignore next: abstract method */ function (/* str */) {\n        throw new Error('write: must be overridden');\n    },\n    /**\n     * writes the specified string with a newline at the end\n     * @method println\n     * @param {String} str the string to write\n     */\n    println: function (str) { this.write(str + '\\n'); }\n};\n\n/**\n * abstract interface for writing files and assets. The caller is expected to\n * call `done` on the writer after it has finished writing all the required\n * files. The writer is an event-emitter that emits a `done` event when `done`\n * is called on it *and* all files have successfully been written.\n *\n * @class Writer\n * @constructor\n */\nfunction Writer() {\n    EventEmitter.call(this);\n}\n\nutil.inherits(Writer, EventEmitter);\n\nextend(Writer, {\n    /**\n     * allows writing content to a file using a callback that is passed a content writer\n     * @method writeFile\n     * @param {String} file the name of the file to write\n     * @param {Function} callback the callback that is called as `callback(contentWriter)`\n     */\n    writeFile: /* istanbul ignore next: abstract method */ function (/* file, callback */) {\n        throw new Error('writeFile: must be overridden');\n    },\n    /**\n     * copies a file from source to destination\n     * @method copyFile\n     * @param {String} source the file to copy, found on the file system\n     * @param {String} dest the destination path\n     */\n    copyFile: /* istanbul ignore next: abstract method */ function (/* source, dest */) {\n        throw new Error('copyFile: must be overridden');\n    },\n    /**\n     * marker method to indicate that the caller is done with this writer object\n     * The writer is expected to emit a `done` event only after this method is called\n     * and it is truly done.\n     * @method done\n     */\n    done: /* istanbul ignore next: abstract method */ function () {\n        throw new Error('done: must be overridden');\n    }\n});\n\nmodule.exports = {\n    Writer: Writer,\n    ContentWriter: ContentWriter\n};\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/util/tree-summarizer.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = require('path'),\n    SEP = path.sep || '/',\n    utils = require('../object-utils');\n\nfunction commonArrayPrefix(first, second) {\n    var len = first.length < second.length ? first.length : second.length,\n        i,\n        ret = [];\n    for (i = 0; i < len; i += 1) {\n        if (first[i] === second[i]) {\n            ret.push(first[i]);\n        } else {\n            break;\n        }\n    }\n    return ret;\n}\n\nfunction findCommonArrayPrefix(args) {\n    if (args.length === 0) {\n        return [];\n    }\n\n    var separated = args.map(function (arg) { return arg.split(SEP); }),\n        ret = separated.pop();\n\n    if (separated.length === 0) {\n        return ret.slice(0, ret.length - 1);\n    } else {\n        return separated.reduce(commonArrayPrefix, ret);\n    }\n}\n\nfunction Node(fullName, kind, metrics) {\n    this.name = fullName;\n    this.fullName = fullName;\n    this.kind = kind;\n    this.metrics = metrics || null;\n    this.parent = null;\n    this.children = [];\n}\n\nNode.prototype = {\n    displayShortName: function () {\n        return this.relativeName;\n    },\n    fullPath: function () {\n        return this.fullName;\n    },\n    addChild: function (child) {\n        this.children.push(child);\n        child.parent = this;\n    },\n    toJSON: function () {\n        return {\n            name: this.name,\n            relativeName: this.relativeName,\n            fullName: this.fullName,\n            kind: this.kind,\n            metrics: this.metrics,\n            parent: this.parent === null ? null : this.parent.name,\n            children: this.children.map(function (node) { return node.toJSON(); })\n        };\n    }\n};\n\nfunction TreeSummary(summaryMap, commonPrefix) {\n    this.prefix = commonPrefix;\n    this.convertToTree(summaryMap, commonPrefix);\n}\n\nTreeSummary.prototype = {\n    getNode: function (shortName) {\n        return this.map[shortName];\n    },\n    convertToTree: function (summaryMap, arrayPrefix) {\n        var nodes = [],\n            rootPath = arrayPrefix.join(SEP) + SEP,\n            root = new Node(rootPath, 'dir'),\n            tmp,\n            tmpChildren,\n            seen = {},\n            filesUnderRoot = false;\n\n        seen[rootPath] = root;\n        Object.keys(summaryMap).forEach(function (key) {\n            var metrics = summaryMap[key],\n                node,\n                parentPath,\n                parent;\n            node = new Node(key, 'file', metrics);\n            seen[key] = node;\n            nodes.push(node);\n            parentPath = path.dirname(key) + SEP;\n            if (parentPath === SEP + SEP || parentPath === '.' + SEP) {\n                parentPath = SEP + '__root__' + SEP;\n            }\n            parent = seen[parentPath];\n            if (!parent) {\n                parent = new Node(parentPath, 'dir');\n                root.addChild(parent);\n                seen[parentPath] = parent;\n            }\n            parent.addChild(node);\n            if (parent === root) { filesUnderRoot = true; }\n        });\n\n        if (filesUnderRoot && arrayPrefix.length > 0) {\n            arrayPrefix.pop(); //start at one level above\n            tmp = root;\n            tmpChildren = tmp.children;\n            tmp.children = [];\n            root = new Node(arrayPrefix.join(SEP) + SEP, 'dir');\n            root.addChild(tmp);\n            tmpChildren.forEach(function (child) {\n                if (child.kind === 'dir') {\n                    root.addChild(child);\n                } else {\n                    tmp.addChild(child);\n                }\n            });\n        }\n        this.fixupNodes(root, arrayPrefix.join(SEP) + SEP);\n        this.calculateMetrics(root);\n        this.root = root;\n        this.map = {};\n        this.indexAndSortTree(root, this.map);\n    },\n\n    fixupNodes: function (node, prefix, parent) {\n        var that = this;\n        if (node.name.indexOf(prefix) === 0) {\n            node.name = node.name.substring(prefix.length);\n        }\n        if (node.name.charAt(0) === SEP) {\n            node.name = node.name.substring(1);\n        }\n        if (parent) {\n            if (parent.name !== '__root__' + SEP) {\n                node.relativeName = node.name.substring(parent.name.length);\n            } else {\n                node.relativeName = node.name;\n            }\n        } else {\n            node.relativeName = node.name.substring(prefix.length);\n        }\n        node.children.forEach(function (child) {\n            that.fixupNodes(child, prefix, node);\n        });\n    },\n    calculateMetrics: function (entry) {\n        var that = this,\n            fileChildren;\n        if (entry.kind !== 'dir') {return; }\n        entry.children.forEach(function (child) {\n            that.calculateMetrics(child);\n        });\n        entry.metrics = utils.mergeSummaryObjects.apply(\n            null,\n            entry.children.map(function (child) { return child.metrics; })\n        );\n        // calclulate \"java-style\" package metrics where there is no hierarchy\n        // across packages\n        fileChildren = entry.children.filter(function (n) { return n.kind !== 'dir'; });\n        if (fileChildren.length > 0) {\n            entry.packageMetrics = utils.mergeSummaryObjects.apply(\n                null,\n                fileChildren.map(function (child) { return child.metrics; })\n            );\n        } else {\n            entry.packageMetrics = null;\n        }\n    },\n    indexAndSortTree: function (node, map) {\n        var that = this;\n        map[node.name] = node;\n        node.children.sort(function (a, b) {\n            a = a.relativeName;\n            b = b.relativeName;\n            return a < b ? -1 : a > b ? 1 : 0;\n        });\n        node.children.forEach(function (child) {\n            that.indexAndSortTree(child, map);\n        });\n    },\n    toJSON: function () {\n        return {\n            prefix: this.prefix,\n            root: this.root.toJSON()\n        };\n    }\n};\n\nfunction TreeSummarizer() {\n    this.summaryMap = {};\n}\n\nTreeSummarizer.prototype = {\n    addFileCoverageSummary: function (filePath, metrics) {\n        this.summaryMap[filePath] = metrics;\n    },\n    getTreeSummary: function () {\n        var commonArrayPrefix = findCommonArrayPrefix(Object.keys(this.summaryMap));\n        return new TreeSummary(this.summaryMap, commonArrayPrefix);\n    }\n};\n\nmodule.exports = TreeSummarizer;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/object-utils.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/**\n * utility methods to process coverage objects. A coverage object has the following\n * format.\n *\n *      {\n *          \"/path/to/file1.js\": { file1 coverage },\n *          \"/path/to/file2.js\": { file2 coverage }\n *      }\n *\n *  The internals of the file coverage object are intentionally not documented since\n *  it is not a public interface.\n *\n *  *Note:* When a method of this module has the word `File` in it, it will accept\n *  one of the sub-objects of the main coverage object as an argument. Other\n *  methods accept the higher level coverage object with multiple keys.\n *\n * Works on `node` as well as the browser.\n *\n * Usage on nodejs\n * ---------------\n *\n *      var objectUtils = require('istanbul').utils;\n *\n * Usage in a browser\n * ------------------\n *\n * Load this file using a `script` tag or other means. This will set `window.coverageUtils`\n * to this module's exports.\n *\n * @class ObjectUtils\n * @module main\n * @static\n */\n(function (isNode) {\n    /**\n     * adds line coverage information to a file coverage object, reverse-engineering\n     * it from statement coverage. The object passed in is updated in place.\n     *\n     * Note that if line coverage information is already present in the object,\n     * it is not recomputed.\n     *\n     * @method addDerivedInfoForFile\n     * @static\n     * @param {Object} fileCoverage the coverage object for a single file\n     */\n    function addDerivedInfoForFile(fileCoverage) {\n        var statementMap = fileCoverage.statementMap,\n            statements = fileCoverage.s,\n            lineMap;\n\n        if (!fileCoverage.l) {\n            fileCoverage.l = lineMap = {};\n            Object.keys(statements).forEach(function (st) {\n                var line = statementMap[st].start.line,\n                    count = statements[st],\n                    prevVal = lineMap[line];\n                if (count === 0 && statementMap[st].skip) { count = 1; }\n                if (typeof prevVal === 'undefined' || prevVal < count) {\n                    lineMap[line] = count;\n                }\n            });\n        }\n    }\n    /**\n     * adds line coverage information to all file coverage objects.\n     *\n     * @method addDerivedInfo\n     * @static\n     * @param {Object} coverage the coverage object\n     */\n    function addDerivedInfo(coverage) {\n        Object.keys(coverage).forEach(function (k) {\n            addDerivedInfoForFile(coverage[k]);\n        });\n    }\n    /**\n     * removes line coverage information from all file coverage objects\n     * @method removeDerivedInfo\n     * @static\n     * @param {Object} coverage the coverage object\n     */\n    function removeDerivedInfo(coverage) {\n        Object.keys(coverage).forEach(function (k) {\n            delete coverage[k].l;\n        });\n    }\n\n    function percent(covered, total) {\n        var tmp;\n        if (total > 0) {\n            tmp = 1000 * 100 * covered / total + 5;\n            return Math.floor(tmp / 10) / 100;\n        } else {\n            return 100.00;\n        }\n    }\n\n    function computeSimpleTotals(fileCoverage, property, mapProperty) {\n        var stats = fileCoverage[property],\n            map = mapProperty ? fileCoverage[mapProperty] : null,\n            ret = { total: 0, covered: 0, skipped: 0 };\n\n        Object.keys(stats).forEach(function (key) {\n            var covered = !!stats[key],\n                skipped = map && map[key].skip;\n            ret.total += 1;\n            if (covered || skipped) {\n                ret.covered += 1;\n            }\n            if (!covered && skipped) {\n                ret.skipped += 1;\n            }\n        });\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n\n    function computeBranchTotals(fileCoverage) {\n        var stats = fileCoverage.b,\n            branchMap = fileCoverage.branchMap,\n            ret = { total: 0, covered: 0, skipped: 0 };\n\n        Object.keys(stats).forEach(function (key) {\n            var branches = stats[key],\n                map = branchMap[key],\n                covered,\n                skipped,\n                i;\n            for (i = 0; i < branches.length; i += 1) {\n                covered = branches[i] > 0;\n                skipped = map.locations && map.locations[i] && map.locations[i].skip;\n                if (covered || skipped) {\n                    ret.covered += 1;\n                }\n                if (!covered && skipped) {\n                    ret.skipped += 1;\n                }\n            }\n            ret.total += branches.length;\n        });\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n    /**\n     * returns a blank summary metrics object. A metrics object has the following\n     * format.\n     *\n     *      {\n     *          lines: lineMetrics,\n     *          statements: statementMetrics,\n     *          functions: functionMetrics,\n     *          branches: branchMetrics\n     *          linesCovered: lineCoveredCount\n     *      }\n     *\n     *  Each individual metric object looks as follows:\n     *\n     *      {\n     *          total: n,\n     *          covered: m,\n     *          pct: percent\n     *      }\n     *\n     * @method blankSummary\n     * @static\n     * @return {Object} a blank metrics object\n     */\n    function blankSummary() {\n        return {\n            lines: {\n                total: 0,\n                covered: 0,\n                skipped: 0,\n                pct: 'Unknown'\n            },\n            statements: {\n                total: 0,\n                covered: 0,\n                skipped: 0,\n                pct: 'Unknown'\n            },\n            functions: {\n                total: 0,\n                covered: 0,\n                skipped: 0,\n                pct: 'Unknown'\n            },\n            branches: {\n                total: 0,\n                covered: 0,\n                skipped: 0,\n                pct: 'Unknown'\n            },\n            linesCovered: {}\n        };\n    }\n    /**\n     * returns the summary metrics given the coverage object for a single file. See `blankSummary()`\n     * to understand the format of the returned object.\n     *\n     * @method summarizeFileCoverage\n     * @static\n     * @param {Object} fileCoverage the coverage object for a single file.\n     * @return {Object} the summary metrics for the file\n     */\n    function summarizeFileCoverage(fileCoverage) {\n        var ret = blankSummary();\n        addDerivedInfoForFile(fileCoverage);\n        ret.lines = computeSimpleTotals(fileCoverage, 'l');\n        ret.functions = computeSimpleTotals(fileCoverage, 'f', 'fnMap');\n        ret.statements = computeSimpleTotals(fileCoverage, 's', 'statementMap');\n        ret.branches = computeBranchTotals(fileCoverage);\n        ret.linesCovered = fileCoverage.l;\n        return ret;\n    }\n    /**\n     * merges two instances of file coverage objects *for the same file*\n     * such that the execution counts are correct.\n     *\n     * @method mergeFileCoverage\n     * @static\n     * @param {Object} first the first file coverage object for a given file\n     * @param {Object} second the second file coverage object for the same file\n     * @return {Object} an object that is a result of merging the two. Note that\n     *      the input objects are not changed in any way.\n     */\n    function mergeFileCoverage(first, second) {\n        var ret = JSON.parse(JSON.stringify(first)),\n            i;\n\n        delete ret.l; //remove derived info\n\n        Object.keys(second.s).forEach(function (k) {\n            ret.s[k] += second.s[k];\n        });\n        Object.keys(second.f).forEach(function (k) {\n            ret.f[k] += second.f[k];\n        });\n        Object.keys(second.b).forEach(function (k) {\n            var retArray = ret.b[k],\n                secondArray = second.b[k];\n            for (i = 0; i < retArray.length; i += 1) {\n                retArray[i] += secondArray[i];\n            }\n        });\n\n        return ret;\n    }\n    /**\n     * merges multiple summary metrics objects by summing up the `totals` and\n     * `covered` fields and recomputing the percentages. This function is generic\n     * and can accept any number of arguments.\n     *\n     * @method mergeSummaryObjects\n     * @static\n     * @param {Object} summary... multiple summary metrics objects\n     * @return {Object} the merged summary metrics\n     */\n    function mergeSummaryObjects() {\n        var ret = blankSummary(),\n            args = Array.prototype.slice.call(arguments),\n            keys = ['lines', 'statements', 'branches', 'functions'],\n            increment = function (obj) {\n                if (obj) {\n                    keys.forEach(function (key) {\n                        ret[key].total += obj[key].total;\n                        ret[key].covered += obj[key].covered;\n                        ret[key].skipped += obj[key].skipped;\n                    });\n\n                    // keep track of all lines we have coverage for.\n                    Object.keys(obj.linesCovered).forEach(function (key) {\n                        if (!ret.linesCovered[key]) {\n                            ret.linesCovered[key] = obj.linesCovered[key];\n                        } else {\n                            ret.linesCovered[key] += obj.linesCovered[key];\n                        }\n                    });\n                }\n            };\n        args.forEach(function (arg) {\n            increment(arg);\n        });\n        keys.forEach(function (key) {\n            ret[key].pct = percent(ret[key].covered, ret[key].total);\n        });\n\n        return ret;\n    }\n    /**\n     * returns the coverage summary for a single coverage object. This is\n     * wrapper over `summarizeFileCoverage` and `mergeSummaryObjects` for\n     * the common case of a single coverage object\n     * @method summarizeCoverage\n     * @static\n     * @param {Object} coverage  the coverage object\n     * @return {Object} summary coverage metrics across all files in the coverage object\n     */\n    function summarizeCoverage(coverage) {\n        var fileSummary = [];\n        Object.keys(coverage).forEach(function (key) {\n            fileSummary.push(summarizeFileCoverage(coverage[key]));\n        });\n        return mergeSummaryObjects.apply(null, fileSummary);\n    }\n\n    /**\n     * makes the coverage object generated by this library yuitest_coverage compatible.\n     * Note that this transformation is lossy since the returned object will not have\n     * statement and branch coverage.\n     *\n     * @method toYUICoverage\n     * @static\n     * @param {Object} coverage The `istanbul` coverage object\n     * @return {Object} a coverage object in `yuitest_coverage` format.\n     */\n    function toYUICoverage(coverage) {\n        var ret = {};\n\n        addDerivedInfo(coverage);\n\n        Object.keys(coverage).forEach(function (k) {\n            var fileCoverage = coverage[k],\n                lines = fileCoverage.l,\n                functions = fileCoverage.f,\n                fnMap = fileCoverage.fnMap,\n                o;\n\n            o = ret[k] = {\n                lines: {},\n                calledLines: 0,\n                coveredLines: 0,\n                functions: {},\n                calledFunctions: 0,\n                coveredFunctions: 0\n            };\n            Object.keys(lines).forEach(function (k) {\n                o.lines[k] = lines[k];\n                o.coveredLines += 1;\n                if (lines[k] > 0) {\n                    o.calledLines += 1;\n                }\n            });\n            Object.keys(functions).forEach(function (k) {\n                var name = fnMap[k].name + ':' + fnMap[k].line;\n                o.functions[name] = functions[k];\n                o.coveredFunctions += 1;\n                if (functions[k] > 0) {\n                    o.calledFunctions += 1;\n                }\n            });\n        });\n        return ret;\n    }\n\n    /**\n     * Creates new file coverage object with incremented hits count\n     * on skipped statements, branches and functions\n     *\n     * @method incrementIgnoredTotals\n     * @static\n     * @param {Object} cov File coverage object\n     * @return {Object} New file coverage object\n     */\n    function incrementIgnoredTotals(cov) {\n        //TODO: This may be slow in the browser and may break in older browsers\n        //      Look into using a library that works in Node and the browser\n        var fileCoverage = JSON.parse(JSON.stringify(cov));\n\n        [\n            {mapKey: 'statementMap', hitsKey: 's'},\n            {mapKey: 'branchMap', hitsKey: 'b'},\n            {mapKey: 'fnMap', hitsKey: 'f'}\n        ].forEach(function (keys) {\n            Object.keys(fileCoverage[keys.mapKey])\n                .forEach(function (key) {\n                    var map = fileCoverage[keys.mapKey][key];\n                    var hits = fileCoverage[keys.hitsKey];\n\n                    if (keys.mapKey === 'branchMap') {\n                        var locations = map.locations;\n\n                        locations.forEach(function (location, index) {\n                            if (hits[key][index] === 0 && location.skip) {\n                                hits[key][index] = 1;\n                            }\n                        });\n\n                        return;\n                    }\n\n                    if (hits[key] === 0 && map.skip) {\n                        hits[key] = 1;\n                    }\n                });\n            });\n\n        return fileCoverage;\n    }\n\n    var exportables = {\n        addDerivedInfo: addDerivedInfo,\n        addDerivedInfoForFile: addDerivedInfoForFile,\n        removeDerivedInfo: removeDerivedInfo,\n        blankSummary: blankSummary,\n        summarizeFileCoverage: summarizeFileCoverage,\n        summarizeCoverage: summarizeCoverage,\n        mergeFileCoverage: mergeFileCoverage,\n        mergeSummaryObjects: mergeSummaryObjects,\n        toYUICoverage: toYUICoverage,\n        incrementIgnoredTotals: incrementIgnoredTotals\n    };\n\n    /* istanbul ignore else: windows */\n    if (isNode) {\n        module.exports = exportables;\n    } else {\n        window.coverageUtils = exportables;\n    }\n}(typeof module !== 'undefined' && typeof module.exports !== 'undefined' && typeof exports !== 'undefined'));\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/cobertura.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = require('path'),\n    util = require('util'),\n    Report = require('./index'),\n    FileWriter = require('../util/file-writer'),\n    TreeSummarizer = require('../util/tree-summarizer'),\n    utils = require('../object-utils');\n\n/**\n * a `Report` implementation that produces a cobertura-style XML file that conforms to the\n * http://cobertura.sourceforge.net/xml/coverage-04.dtd DTD.\n *\n * Usage\n * -----\n *\n *      var report = require('istanbul').Report.create('cobertura');\n *\n * @class CoberturaReport\n * @module report\n * @extends Report\n * @constructor\n * @param {Object} opts optional\n * @param {String} [opts.dir] the directory in which to the cobertura-coverage.xml will be written\n */\nfunction CoberturaReport(opts) {\n    Report.call(this);\n    opts = opts || {};\n    this.projectRoot = process.cwd();\n    this.dir = opts.dir || this.projectRoot;\n    this.file = opts.file || this.getDefaultConfig().file;\n    this.opts = opts;\n}\n\nCoberturaReport.TYPE = 'cobertura';\nutil.inherits(CoberturaReport, Report);\n\nfunction asJavaPackage(node) {\n    return node.displayShortName().\n        replace(/\\//g, '.').\n        replace(/\\\\/g, '.').\n        replace(/\\.$/, '');\n}\n\nfunction asClassName(node) {\n    /*jslint regexp: true */\n    return node.fullPath().replace(/.*[\\\\\\/]/, '');\n}\n\nfunction quote(thing) {\n    return '\"' + thing + '\"';\n}\n\nfunction attr(n, v) {\n    return ' ' + n + '=' + quote(v) + ' ';\n}\n\nfunction branchCoverageByLine(fileCoverage) {\n    var branchMap = fileCoverage.branchMap,\n        branches = fileCoverage.b,\n        ret = {};\n    Object.keys(branchMap).forEach(function (k) {\n        var line = branchMap[k].line,\n            branchData = branches[k];\n        ret[line] = ret[line] || [];\n        ret[line].push.apply(ret[line], branchData);\n    });\n    Object.keys(ret).forEach(function (k) {\n        var dataArray = ret[k],\n            covered = dataArray.filter(function (item) { return item > 0; }),\n            coverage = covered.length / dataArray.length * 100;\n        ret[k] = { covered: covered.length, total: dataArray.length, coverage: coverage };\n    });\n    return ret;\n}\n\nfunction addClassStats(node, fileCoverage, writer, projectRoot) {\n    fileCoverage = utils.incrementIgnoredTotals(fileCoverage);\n\n    var metrics = node.metrics,\n        branchByLine = branchCoverageByLine(fileCoverage),\n        fnMap,\n        lines;\n\n    writer.println('\\t\\t<class' +\n        attr('name', asClassName(node)) +\n        attr('filename', path.relative(projectRoot, node.fullPath())) +\n        attr('line-rate', metrics.lines.pct / 100.0) +\n        attr('branch-rate', metrics.branches.pct / 100.0) +\n        '>');\n\n    writer.println('\\t\\t<methods>');\n    fnMap = fileCoverage.fnMap;\n    Object.keys(fnMap).forEach(function (k) {\n        var name = fnMap[k].name,\n            hits = fileCoverage.f[k];\n\n        writer.println(\n            '\\t\\t\\t<method' +\n            attr('name', name) +\n            attr('hits', hits) +\n            attr('signature', '()V') + //fake out a no-args void return\n            '>'\n        );\n\n        //Add the function definition line and hits so that jenkins cobertura plugin records method hits\n        writer.println(\n            '\\t\\t\\t\\t<lines>' +\n             '<line' +\n            attr('number', fnMap[k].line) +\n            attr('hits', fileCoverage.f[k]) +\n            '/>' +\n            '</lines>'\n        );\n\n        writer.println('\\t\\t\\t</method>');\n\n    });\n    writer.println('\\t\\t</methods>');\n\n    writer.println('\\t\\t<lines>');\n    lines = fileCoverage.l;\n    Object.keys(lines).forEach(function (k) {\n        var str = '\\t\\t\\t<line' +\n            attr('number', k) +\n            attr('hits', lines[k]),\n            branchDetail = branchByLine[k];\n\n        if (!branchDetail) {\n            str += attr('branch', false);\n        } else {\n            str += attr('branch', true) +\n                attr('condition-coverage', branchDetail.coverage +\n                    '% (' + branchDetail.covered + '/' + branchDetail.total + ')');\n        }\n        writer.println(str + '/>');\n    });\n    writer.println('\\t\\t</lines>');\n\n    writer.println('\\t\\t</class>');\n}\n\nfunction walk(node, collector, writer, level, projectRoot) {\n    var metrics;\n    if (level === 0) {\n        metrics = node.metrics;\n        writer.println('<?xml version=\"1.0\" ?>');\n        writer.println('<!DOCTYPE coverage SYSTEM \"http://cobertura.sourceforge.net/xml/coverage-04.dtd\">');\n        writer.println('<coverage' +\n            attr('lines-valid', metrics.lines.total) +\n            attr('lines-covered', metrics.lines.covered) +\n            attr('line-rate', metrics.lines.pct / 100.0) +\n            attr('branches-valid', metrics.branches.total) +\n            attr('branches-covered', metrics.branches.covered) +\n            attr('branch-rate', metrics.branches.pct / 100.0) +\n            attr('timestamp', Date.now()) +\n            'complexity=\"0\" version=\"0.1\">');\n        writer.println('<sources>');\n        writer.println('\\t<source>' + projectRoot + '</source>');\n        writer.println('</sources>');\n        writer.println('<packages>');\n    }\n    if (node.packageMetrics) {\n        metrics = node.packageMetrics;\n        writer.println('\\t<package' +\n            attr('name', asJavaPackage(node)) +\n            attr('line-rate', metrics.lines.pct / 100.0) +\n            attr('branch-rate', metrics.branches.pct / 100.0) +\n            '>');\n        writer.println('\\t<classes>');\n        node.children.filter(function (child) { return child.kind !== 'dir'; }).\n            forEach(function (child) {\n                addClassStats(child, collector.fileCoverageFor(child.fullPath()), writer, projectRoot);\n            });\n        writer.println('\\t</classes>');\n        writer.println('\\t</package>');\n    }\n    node.children.filter(function (child) { return child.kind === 'dir'; }).\n        forEach(function (child) {\n            walk(child, collector, writer, level + 1, projectRoot);\n        });\n\n    if (level === 0) {\n        writer.println('</packages>');\n        writer.println('</coverage>');\n    }\n}\n\nReport.mix(CoberturaReport, {\n    synopsis: function () {\n        return 'XML coverage report that can be consumed by the cobertura tool';\n    },\n    getDefaultConfig: function () {\n        return { file: 'cobertura-coverage.xml' };\n    },\n    writeReport: function (collector, sync) {\n        var summarizer = new TreeSummarizer(),\n            outputFile = path.join(this.dir, this.file),\n            writer = this.opts.writer || new FileWriter(sync),\n            projectRoot = this.projectRoot,\n            that = this,\n            tree,\n            root;\n\n        collector.files().forEach(function (key) {\n            summarizer.addFileCoverageSummary(key, utils.summarizeFileCoverage(collector.fileCoverageFor(key)));\n        });\n        tree = summarizer.getTreeSummary();\n        root = tree.root;\n        writer.on('done', function () { that.emit('done'); });\n        writer.writeFile(outputFile, function (contentWriter) {\n            walk(root, collector, contentWriter, 0, projectRoot);\n            writer.done();\n        });\n    }\n});\n\nmodule.exports = CoberturaReport;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/html.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/*jshint maxlen: 300 */\nvar handlebars = require('handlebars').create(),\n    defaults = require('./common/defaults'),\n    path = require('path'),\n    fs = require('fs'),\n    util = require('util'),\n    FileWriter = require('../util/file-writer'),\n    Report = require('./index'),\n    Store = require('../store'),\n    InsertionText = require('../util/insertion-text'),\n    TreeSummarizer = require('../util/tree-summarizer'),\n    utils = require('../object-utils'),\n    templateFor = function (name) { return handlebars.compile(fs.readFileSync(path.resolve(__dirname, 'templates', name + '.txt'), 'utf8')); },\n    headerTemplate = templateFor('head'),\n    footerTemplate = templateFor('foot'),\n    detailTemplate = handlebars.compile([\n        '<tr>',\n        '<td class=\"line-count quiet\">{{#show_lines}}{{maxLines}}{{/show_lines}}</td>',\n        '<td class=\"line-coverage quiet\">{{#show_line_execution_counts fileCoverage}}{{maxLines}}{{/show_line_execution_counts}}</td>',\n        '<td class=\"text\"><pre class=\"prettyprint lang-js\">{{#show_code structured}}{{/show_code}}</pre></td>',\n        '</tr>\\n'\n    ].join('')),\n    summaryTableHeader = [\n        '<div class=\"pad1\">',\n        '<table class=\"coverage-summary\">',\n        '<thead>',\n        '<tr>',\n        '   <th data-col=\"file\" data-fmt=\"html\" data-html=\"true\" class=\"file\">File</th>',\n        '   <th data-col=\"pic\" data-type=\"number\" data-fmt=\"html\" data-html=\"true\" class=\"pic\"></th>',\n        '   <th data-col=\"statements\" data-type=\"number\" data-fmt=\"pct\" class=\"pct\">Statements</th>',\n        '   <th data-col=\"statements_raw\" data-type=\"number\" data-fmt=\"html\" class=\"abs\"></th>',\n        '   <th data-col=\"branches\" data-type=\"number\" data-fmt=\"pct\" class=\"pct\">Branches</th>',\n        '   <th data-col=\"branches_raw\" data-type=\"number\" data-fmt=\"html\" class=\"abs\"></th>',\n        '   <th data-col=\"functions\" data-type=\"number\" data-fmt=\"pct\" class=\"pct\">Functions</th>',\n        '   <th data-col=\"functions_raw\" data-type=\"number\" data-fmt=\"html\" class=\"abs\"></th>',\n        '   <th data-col=\"lines\" data-type=\"number\" data-fmt=\"pct\" class=\"pct\">Lines</th>',\n        '   <th data-col=\"lines_raw\" data-type=\"number\" data-fmt=\"html\" class=\"abs\"></th>',\n        '</tr>',\n        '</thead>',\n        '<tbody>'\n    ].join('\\n'),\n    summaryLineTemplate = handlebars.compile([\n        '<tr>',\n        '<td class=\"file {{reportClasses.statements}}\" data-value=\"{{file}}\"><a href=\"{{output}}\">{{file}}</a></td>',\n        '<td data-value=\"{{metrics.statements.pct}}\" class=\"pic {{reportClasses.statements}}\"><div class=\"chart\">{{#show_picture}}{{metrics.statements.pct}}{{/show_picture}}</div></td>',\n        '<td data-value=\"{{metrics.statements.pct}}\" class=\"pct {{reportClasses.statements}}\">{{metrics.statements.pct}}%</td>',\n        '<td data-value=\"{{metrics.statements.total}}\" class=\"abs {{reportClasses.statements}}\">{{metrics.statements.covered}}/{{metrics.statements.total}}</td>',\n        '<td data-value=\"{{metrics.branches.pct}}\" class=\"pct {{reportClasses.branches}}\">{{metrics.branches.pct}}%</td>',\n        '<td data-value=\"{{metrics.branches.total}}\" class=\"abs {{reportClasses.branches}}\">{{metrics.branches.covered}}/{{metrics.branches.total}}</td>',\n        '<td data-value=\"{{metrics.functions.pct}}\" class=\"pct {{reportClasses.functions}}\">{{metrics.functions.pct}}%</td>',\n        '<td data-value=\"{{metrics.functions.total}}\" class=\"abs {{reportClasses.functions}}\">{{metrics.functions.covered}}/{{metrics.functions.total}}</td>',\n        '<td data-value=\"{{metrics.lines.pct}}\" class=\"pct {{reportClasses.lines}}\">{{metrics.lines.pct}}%</td>',\n        '<td data-value=\"{{metrics.lines.total}}\" class=\"abs {{reportClasses.lines}}\">{{metrics.lines.covered}}/{{metrics.lines.total}}</td>',\n        '</tr>\\n'\n    ].join('\\n\\t')),\n    summaryTableFooter = [\n        '</tbody>',\n        '</table>',\n        '</div>'\n    ].join('\\n'),\n    lt = '\\u0001',\n    gt = '\\u0002',\n    RE_LT = /</g,\n    RE_GT = />/g,\n    RE_AMP = /&/g,\n    RE_lt = /\\u0001/g,\n    RE_gt = /\\u0002/g;\n\nhandlebars.registerHelper('show_picture', function (opts) {\n    var num = Number(opts.fn(this)),\n        rest,\n        cls = '';\n    if (isFinite(num)) {\n        if (num === 100) {\n            cls = ' cover-full';\n        }\n        num = Math.floor(num);\n        rest = 100 - num;\n        return '<div class=\"cover-fill' + cls + '\" style=\"width: ' + num + '%;\"></div>' +\n            '<div class=\"cover-empty\" style=\"width:' + rest + '%;\"></div>';\n    } else {\n        return '';\n    }\n});\n\nhandlebars.registerHelper('if_has_ignores', function (metrics, opts) {\n    return (metrics.statements.skipped +\n        metrics.functions.skipped +\n        metrics.branches.skipped) === 0 ? '' : opts.fn(this);\n});\n\nhandlebars.registerHelper('show_ignores', function (metrics) {\n    var statements = metrics.statements.skipped,\n        functions = metrics.functions.skipped,\n        branches = metrics.branches.skipped,\n        result;\n\n    if (statements === 0 && functions === 0 && branches === 0) {\n        return '<span class=\"ignore-none\">none</span>';\n    }\n\n    result = [];\n    if (statements >0) { result.push(statements === 1 ? '1 statement': statements + ' statements'); }\n    if (functions >0) { result.push(functions === 1 ? '1 function' : functions + ' functions'); }\n    if (branches >0) { result.push(branches === 1 ? '1 branch' : branches + ' branches'); }\n\n    return result.join(', ');\n});\n\nhandlebars.registerHelper('show_lines', function (opts) {\n    var maxLines = Number(opts.fn(this)),\n        i,\n        array = [];\n\n    for (i = 0; i < maxLines; i += 1) {\n        array[i] = i + 1;\n    }\n    return array.join('\\n');\n});\n\nhandlebars.registerHelper('show_line_execution_counts', function (context, opts) {\n    var lines = context.l,\n        maxLines = Number(opts.fn(this)),\n        i,\n        lineNumber,\n        array = [],\n        covered,\n        value = '';\n\n    for (i = 0; i < maxLines; i += 1) {\n        lineNumber = i + 1;\n        value = '&nbsp;';\n        covered = 'neutral';\n        if (lines.hasOwnProperty(lineNumber)) {\n            if (lines[lineNumber] > 0) {\n                covered = 'yes';\n                value = lines[lineNumber] + '';\n            } else {\n                covered = 'no';\n            }\n        }\n        array.push('<span class=\"cline-any cline-' + covered + '\">' + value + '</span>');\n    }\n    return array.join('\\n');\n});\n\nfunction customEscape(text) {\n    text = text.toString();\n    return text.replace(RE_AMP, '&amp;')\n        .replace(RE_LT, '&lt;')\n        .replace(RE_GT, '&gt;')\n        .replace(RE_lt, '<')\n        .replace(RE_gt, '>');\n}\n\nhandlebars.registerHelper('show_code', function (context /*, opts */) {\n    var array = [];\n\n    context.forEach(function (item) {\n        array.push(customEscape(item.text) || '&nbsp;');\n    });\n    return array.join('\\n');\n});\n\nfunction title(str) {\n    return ' title=\"' + str + '\" ';\n}\n\nfunction annotateLines(fileCoverage, structuredText) {\n    var lineStats = fileCoverage.l;\n    if (!lineStats) { return; }\n    Object.keys(lineStats).forEach(function (lineNumber) {\n        var count = lineStats[lineNumber];\n        if (structuredText[lineNumber]) {\n          structuredText[lineNumber].covered = count > 0 ? 'yes' : 'no';\n        }\n    });\n    structuredText.forEach(function (item) {\n        if (item.covered === null) {\n            item.covered = 'neutral';\n        }\n    });\n}\n\nfunction annotateStatements(fileCoverage, structuredText) {\n    var statementStats = fileCoverage.s,\n        statementMeta = fileCoverage.statementMap;\n    Object.keys(statementStats).forEach(function (stName) {\n        var count = statementStats[stName],\n            meta = statementMeta[stName],\n            type = count > 0 ? 'yes' : 'no',\n            startCol = meta.start.column,\n            endCol = meta.end.column + 1,\n            startLine = meta.start.line,\n            endLine = meta.end.line,\n            openSpan = lt + 'span class=\"' + (meta.skip ? 'cstat-skip' : 'cstat-no') + '\"' + title('statement not covered') + gt,\n            closeSpan = lt + '/span' + gt,\n            text;\n\n        if (type === 'no') {\n            if (endLine !== startLine) {\n                endLine = startLine;\n                endCol = structuredText[startLine].text.originalLength();\n            }\n            text = structuredText[startLine].text;\n            text.wrap(startCol,\n                openSpan,\n                startLine === endLine ? endCol : text.originalLength(),\n                closeSpan);\n        }\n    });\n}\n\nfunction annotateFunctions(fileCoverage, structuredText) {\n\n    var fnStats = fileCoverage.f,\n        fnMeta = fileCoverage.fnMap;\n    if (!fnStats) { return; }\n    Object.keys(fnStats).forEach(function (fName) {\n        var count = fnStats[fName],\n            meta = fnMeta[fName],\n            type = count > 0 ? 'yes' : 'no',\n            startCol = meta.loc.start.column,\n            endCol = meta.loc.end.column + 1,\n            startLine = meta.loc.start.line,\n            endLine = meta.loc.end.line,\n            openSpan = lt + 'span class=\"' + (meta.skip ? 'fstat-skip' : 'fstat-no') + '\"' + title('function not covered') + gt,\n            closeSpan = lt + '/span' + gt,\n            text;\n\n        if (type === 'no') {\n            if (endLine !== startLine) {\n                endLine = startLine;\n                endCol = structuredText[startLine].text.originalLength();\n            }\n            text = structuredText[startLine].text;\n            text.wrap(startCol,\n                openSpan,\n                startLine === endLine ? endCol : text.originalLength(),\n                closeSpan);\n        }\n    });\n}\n\nfunction annotateBranches(fileCoverage, structuredText) {\n    var branchStats = fileCoverage.b,\n        branchMeta = fileCoverage.branchMap;\n    if (!branchStats) { return; }\n\n    Object.keys(branchStats).forEach(function (branchName) {\n        var branchArray = branchStats[branchName],\n            sumCount = branchArray.reduce(function (p, n) { return p + n; }, 0),\n            metaArray = branchMeta[branchName].locations,\n            i,\n            count,\n            meta,\n            type,\n            startCol,\n            endCol,\n            startLine,\n            endLine,\n            openSpan,\n            closeSpan,\n            text;\n\n        if (sumCount > 0) { //only highlight if partial branches are missing\n            for (i = 0; i < branchArray.length; i += 1) {\n                count = branchArray[i];\n                meta = metaArray[i];\n                type = count > 0 ? 'yes' : 'no';\n                startCol = meta.start.column;\n                endCol = meta.end.column + 1;\n                startLine = meta.start.line;\n                endLine = meta.end.line;\n                openSpan = lt + 'span class=\"branch-' + i + ' ' + (meta.skip ? 'cbranch-skip' : 'cbranch-no') + '\"' + title('branch not covered') + gt;\n                closeSpan = lt + '/span' + gt;\n\n                if (count === 0) { //skip branches taken\n                    if (endLine !== startLine) {\n                        endLine = startLine;\n                        endCol = structuredText[startLine].text.originalLength();\n                    }\n                    text = structuredText[startLine].text;\n                    if (branchMeta[branchName].type === 'if') { // and 'if' is a special case since the else branch might not be visible, being non-existent\n                        text.insertAt(startCol, lt + 'span class=\"' + (meta.skip ? 'skip-if-branch' : 'missing-if-branch') + '\"' +\n                            title((i === 0 ? 'if' : 'else') + ' path not taken') + gt +\n                            (i === 0 ? 'I' : 'E')  + lt + '/span' + gt, true, false);\n                    } else {\n                        text.wrap(startCol,\n                            openSpan,\n                            startLine === endLine ? endCol : text.originalLength(),\n                            closeSpan);\n                    }\n                }\n            }\n        }\n    });\n}\n\nfunction getReportClass(stats, watermark) {\n    var coveragePct = stats.pct,\n        identity  = 1;\n    if (coveragePct * identity === coveragePct) {\n        return coveragePct >= watermark[1] ? 'high' : coveragePct >= watermark[0] ? 'medium' : 'low';\n    } else {\n        return '';\n    }\n}\n\nfunction cleanPath(name) {\n    var SEP = path.sep || '/';\n    return (SEP !== '/') ? name.split(SEP).join('/') : name;\n}\n\nfunction isEmptySourceStore(sourceStore) {\n    if (!sourceStore) {\n        return true;\n    }\n\n    var cache = sourceStore.sourceCache;\n    return cache && !Object.keys(cache).length;\n}\n\n/**\n * a `Report` implementation that produces HTML coverage reports.\n *\n * Usage\n * -----\n *\n *      var report = require('istanbul').Report.create('html');\n *\n *\n * @class HtmlReport\n * @extends Report\n * @module report\n * @constructor\n * @param {Object} opts optional\n * @param {String} [opts.dir] the directory in which to generate reports. Defaults to `./html-report`\n */\nfunction HtmlReport(opts) {\n    Report.call(this);\n    this.opts = opts || {};\n    this.opts.dir = this.opts.dir || path.resolve(process.cwd(), 'html-report');\n    this.opts.sourceStore = isEmptySourceStore(this.opts.sourceStore) ?\n        Store.create('fslookup') : this.opts.sourceStore;\n    this.opts.linkMapper = this.opts.linkMapper || this.standardLinkMapper();\n    this.opts.writer = this.opts.writer || null;\n    this.opts.templateData = { datetime: Date() };\n    this.opts.watermarks = this.opts.watermarks || defaults.watermarks();\n}\n\nHtmlReport.TYPE = 'html';\nutil.inherits(HtmlReport, Report);\n\nReport.mix(HtmlReport, {\n\n    synopsis: function () {\n        return 'Navigable HTML coverage report for every file and directory';\n    },\n\n    getPathHtml: function (node, linkMapper) {\n        var parent = node.parent,\n            nodePath = [],\n            linkPath = [],\n            i;\n\n        while (parent) {\n            nodePath.push(parent);\n            parent = parent.parent;\n        }\n\n        for (i = 0; i < nodePath.length; i += 1) {\n            linkPath.push('<a href=\"' + linkMapper.ancestor(node, i + 1) + '\">' +\n                (cleanPath(nodePath[i].relativeName) || 'all files') + '</a>');\n        }\n        linkPath.reverse();\n        return linkPath.length > 0 ? linkPath.join(' / ') + ' ' +\n            cleanPath(node.displayShortName()) : '/';\n    },\n\n    fillTemplate: function (node, templateData) {\n        var opts = this.opts,\n            linkMapper = opts.linkMapper;\n\n        templateData.entity = node.name || 'All files';\n        templateData.metrics = node.metrics;\n        templateData.reportClass = getReportClass(node.metrics.statements, opts.watermarks.statements);\n        templateData.pathHtml = this.getPathHtml(node, linkMapper);\n        templateData.base = {\n        \tcss: linkMapper.asset(node, 'base.css')\n        };\n        templateData.sorter = {\n            js: linkMapper.asset(node, 'sorter.js'),\n            image: linkMapper.asset(node, 'sort-arrow-sprite.png')\n        };\n        templateData.prettify = {\n            js: linkMapper.asset(node, 'prettify.js'),\n            css: linkMapper.asset(node, 'prettify.css')\n        };\n    },\n    writeDetailPage: function (writer, node, fileCoverage) {\n        var opts = this.opts,\n            sourceStore = opts.sourceStore,\n            templateData = opts.templateData,\n            sourceText = fileCoverage.code && Array.isArray(fileCoverage.code) ?\n                fileCoverage.code.join('\\n') + '\\n' : sourceStore.get(fileCoverage.path),\n            code = sourceText.split(/(?:\\r?\\n)|\\r/),\n            count = 0,\n            structured = code.map(function (str) { count += 1; return { line: count, covered: null, text: new InsertionText(str, true) }; }),\n            context;\n\n        structured.unshift({ line: 0, covered: null, text: new InsertionText(\"\") });\n\n        this.fillTemplate(node, templateData);\n        writer.write(headerTemplate(templateData));\n        writer.write('<pre><table class=\"coverage\">\\n');\n\n        annotateLines(fileCoverage, structured);\n        //note: order is important, since statements typically result in spanning the whole line and doing branches late\n        //causes mismatched tags\n        annotateBranches(fileCoverage, structured);\n        annotateFunctions(fileCoverage, structured);\n        annotateStatements(fileCoverage, structured);\n\n        structured.shift();\n        context = {\n            structured: structured,\n            maxLines: structured.length,\n            fileCoverage: fileCoverage\n        };\n        writer.write(detailTemplate(context));\n        writer.write('</table></pre>\\n');\n        writer.write(footerTemplate(templateData));\n    },\n\n    writeIndexPage: function (writer, node) {\n        var linkMapper = this.opts.linkMapper,\n            templateData = this.opts.templateData,\n            children = Array.prototype.slice.apply(node.children),\n            watermarks = this.opts.watermarks;\n\n        children.sort(function (a, b) {\n            return a.name < b.name ? -1 : 1;\n        });\n\n        this.fillTemplate(node, templateData);\n        writer.write(headerTemplate(templateData));\n        writer.write(summaryTableHeader);\n        children.forEach(function (child) {\n            var metrics = child.metrics,\n                reportClasses = {\n                    statements: getReportClass(metrics.statements, watermarks.statements),\n                    lines: getReportClass(metrics.lines, watermarks.lines),\n                    functions: getReportClass(metrics.functions, watermarks.functions),\n                    branches: getReportClass(metrics.branches, watermarks.branches)\n                },\n                data = {\n                    metrics: metrics,\n                    reportClasses: reportClasses,\n                    file: cleanPath(child.displayShortName()),\n                    output: linkMapper.fromParent(child)\n                };\n            writer.write(summaryLineTemplate(data) + '\\n');\n        });\n        writer.write(summaryTableFooter);\n        writer.write(footerTemplate(templateData));\n    },\n\n    writeFiles: function (writer, node, dir, collector) {\n        var that = this,\n            indexFile = path.resolve(dir, 'index.html'),\n            childFile;\n        if (this.opts.verbose) { console.error('Writing ' + indexFile); }\n        writer.writeFile(indexFile, function (contentWriter) {\n            that.writeIndexPage(contentWriter, node);\n        });\n        node.children.forEach(function (child) {\n            if (child.kind === 'dir') {\n                that.writeFiles(writer, child, path.resolve(dir, child.relativeName), collector);\n            } else {\n                childFile = path.resolve(dir, child.relativeName + '.html');\n                if (that.opts.verbose) { console.error('Writing ' + childFile); }\n                writer.writeFile(childFile, function (contentWriter) {\n                    that.writeDetailPage(contentWriter, child, collector.fileCoverageFor(child.fullPath()));\n                });\n            }\n        });\n    },\n\n    standardLinkMapper: function () {\n        return {\n            fromParent: function (node) {\n                var relativeName = cleanPath(node.relativeName);\n\n                return node.kind === 'dir' ? relativeName + 'index.html' : relativeName + '.html';\n            },\n            ancestorHref: function (node, num) {\n                var href = '',\n                    notDot = function(part) {\n                        return part !== '.';\n                    },\n                    separated,\n                    levels,\n                    i,\n                    j;\n\n                for (i = 0; i < num; i += 1) {\n                    separated = cleanPath(node.relativeName).split('/').filter(notDot);\n                    levels = separated.length - 1;\n                    for (j = 0; j < levels; j += 1) {\n                        href += '../';\n                    }\n                    node = node.parent;\n                }\n                return href;\n            },\n            ancestor: function (node, num) {\n                return this.ancestorHref(node, num) + 'index.html';\n            },\n            asset: function (node, name) {\n                var i = 0,\n                    parent = node.parent;\n                while (parent) { i += 1; parent = parent.parent; }\n                return this.ancestorHref(node, i) + name;\n            }\n        };\n    },\n\n    writeReport: function (collector, sync) {\n        var opts = this.opts,\n            dir = opts.dir,\n            summarizer = new TreeSummarizer(),\n            writer = opts.writer || new FileWriter(sync),\n            that = this,\n            tree,\n            copyAssets = function (subdir) {\n                var srcDir = path.resolve(__dirname, '..', 'assets', subdir);\n                fs.readdirSync(srcDir).forEach(function (f) {\n                    var resolvedSource = path.resolve(srcDir, f),\n                        resolvedDestination = path.resolve(dir, f),\n                        stat = fs.statSync(resolvedSource);\n\n                    if (stat.isFile()) {\n                        if (opts.verbose) {\n                            console.log('Write asset: ' + resolvedDestination);\n                        }\n                        writer.copyFile(resolvedSource, resolvedDestination);\n                    }\n                });\n            };\n\n        collector.files().forEach(function (key) {\n            summarizer.addFileCoverageSummary(key, utils.summarizeFileCoverage(collector.fileCoverageFor(key)));\n        });\n        tree = summarizer.getTreeSummary();\n        [ '.', 'vendor'].forEach(function (subdir) {\n            copyAssets(subdir);\n        });\n        writer.on('done', function () { that.emit('done'); });\n        //console.log(JSON.stringify(tree.root, undefined, 4));\n        this.writeFiles(writer, tree.root, dir, collector);\n        writer.done();\n    }\n});\n\nmodule.exports = HtmlReport;\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/common/defaults.js":"/*\n Copyright (c) 2013, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar Report  = require('../index');\nvar supportsColor = require('supports-color');\n\nmodule.exports = {\n    watermarks: function () {\n        return {\n            statements: [ 50, 80 ],\n            lines: [ 50, 80 ],\n            functions: [ 50, 80],\n            branches: [ 50, 80 ]\n        };\n    },\n\n    classFor: function (type, metrics, watermarks) {\n        var mark = watermarks[type],\n            value = metrics[type].pct;\n        return value >= mark[1] ? 'high' : value >= mark[0] ? 'medium' : 'low';\n    },\n\n    colorize: function (str, clazz) {\n        /* istanbul ignore if: untestable in batch mode */\n        var colors = {\n            low: '31;1',\n            medium: '33;1',\n            high: '32;1'\n        };\n        \n        if (supportsColor && colors[clazz]) {\n            return '\\u001b[' + colors[clazz] + 'm' + str + '\\u001b[0m';\n        }\n        return str;\n    },\n\n    defaultReportConfig: function () {\n        var cfg = {};\n        Report.getReportList().forEach(function (type) {\n            var rpt = Report.create(type),\n                c = rpt.getDefaultConfig();\n            if (c) {\n                cfg[type] = c;\n            }\n        });\n        return cfg;\n    }\n};\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/util/insertion-text.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nfunction InsertionText(text, consumeBlanks) {\n    this.text = text;\n    this.origLength = text.length;\n    this.offsets = [];\n    this.consumeBlanks = consumeBlanks;\n    this.startPos = this.findFirstNonBlank();\n    this.endPos = this.findLastNonBlank();\n}\n\nvar WHITE_RE = /[ \\f\\n\\r\\t\\v\\u00A0\\u2028\\u2029]/;\n\nInsertionText.prototype = {\n\n    findFirstNonBlank: function () {\n        var pos = -1,\n            text = this.text,\n            len = text.length,\n            i;\n        for (i = 0; i < len; i += 1) {\n            if (!text.charAt(i).match(WHITE_RE)) {\n                pos = i;\n                break;\n            }\n        }\n        return pos;\n    },\n    findLastNonBlank: function () {\n        var text = this.text,\n            len = text.length,\n            pos = text.length + 1,\n            i;\n        for (i = len - 1; i >= 0; i -= 1) {\n            if (!text.charAt(i).match(WHITE_RE)) {\n                pos = i;\n                break;\n            }\n        }\n        return pos;\n    },\n    originalLength: function () {\n        return this.origLength;\n    },\n\n    insertAt: function (col, str, insertBefore, consumeBlanks) {\n        consumeBlanks = typeof consumeBlanks === 'undefined' ? this.consumeBlanks : consumeBlanks;\n        col = col > this.originalLength() ? this.originalLength() : col;\n        col = col < 0 ? 0 : col;\n\n        if (consumeBlanks) {\n            if (col <= this.startPos) {\n                col = 0;\n            }\n            if (col > this.endPos) {\n                col = this.origLength;\n            }\n        }\n\n        var len = str.length,\n            offset = this.findOffset(col, len, insertBefore),\n            realPos = col + offset,\n            text = this.text;\n        this.text = text.substring(0, realPos) + str + text.substring(realPos);\n        return this;\n    },\n\n    findOffset: function (pos, len, insertBefore) {\n        var offsets = this.offsets,\n            offsetObj,\n            cumulativeOffset = 0,\n            i;\n\n        for (i = 0; i < offsets.length; i += 1) {\n            offsetObj = offsets[i];\n            if (offsetObj.pos < pos || (offsetObj.pos === pos && !insertBefore)) {\n                cumulativeOffset += offsetObj.len;\n            }\n            if (offsetObj.pos >= pos) {\n                break;\n            }\n        }\n        if (offsetObj && offsetObj.pos === pos) {\n            offsetObj.len += len;\n        } else {\n            offsets.splice(i, 0, { pos: pos, len: len });\n        }\n        return cumulativeOffset;\n    },\n\n    wrap: function (startPos, startText, endPos, endText, consumeBlanks) {\n        this.insertAt(startPos, startText, true, consumeBlanks);\n        this.insertAt(endPos, endText, false, consumeBlanks);\n        return this;\n    },\n\n    wrapLine: function (startText, endText) {\n        this.wrap(0, startText, this.originalLength(), endText);\n    },\n\n    toString: function () {\n        return this.text;\n    }\n};\n\nmodule.exports = InsertionText;","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/json-summary.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = require('path'),\n    objectUtils = require('../object-utils'),\n    Writer = require('../util/file-writer'),\n    util = require('util'),\n    Report = require('./index');\n/**\n * a `Report` implementation that produces a coverage JSON object with summary info only.\n *\n * Usage\n * -----\n *\n *      var report = require('istanbul').Report.create('json-summary');\n *\n *\n * @class JsonSummaryReport\n * @extends Report\n * @module report\n * @constructor\n * @param {Object} opts optional\n * @param {String} [opts.dir] the directory in which to write the `coverage-summary.json` file. Defaults to `process.cwd()`\n */\nfunction JsonSummaryReport(opts) {\n    this.opts = opts || {};\n    this.opts.dir = this.opts.dir || process.cwd();\n    this.opts.file = this.opts.file || this.getDefaultConfig().file;\n    this.opts.writer = this.opts.writer || null;\n}\nJsonSummaryReport.TYPE = 'json-summary';\nutil.inherits(JsonSummaryReport, Report);\n\nReport.mix(JsonSummaryReport, {\n    synopsis: function () {\n        return 'prints a summary coverage object as JSON to a file';\n    },\n    getDefaultConfig: function () {\n        return {\n            file: 'coverage-summary.json'\n        };\n    },\n    writeReport: function (collector, sync) {\n        var outputFile = path.resolve(this.opts.dir, this.opts.file),\n            writer = this.opts.writer || new Writer(sync),\n            that = this;\n\n        var summaries = [],\n            finalSummary;\n        collector.files().forEach(function (file) {\n            summaries.push(objectUtils.summarizeFileCoverage(collector.fileCoverageFor(file)));\n        });\n        finalSummary = objectUtils.mergeSummaryObjects.apply(null, summaries);\n\n        writer.on('done', function () { that.emit('done'); });\n        writer.writeFile(outputFile, function (contentWriter) {\n            contentWriter.println(\"{\");\n            contentWriter.write('\"total\":');\n            contentWriter.write(JSON.stringify(finalSummary));\n\n            collector.files().forEach(function (key) {\n                contentWriter.println(\",\");\n                contentWriter.write(JSON.stringify(key));\n                contentWriter.write(\":\");\n                contentWriter.write(JSON.stringify(objectUtils.summarizeFileCoverage(collector.fileCoverageFor(key))));\n            });\n            contentWriter.println(\"}\");\n        });\n        writer.done();\n    }\n});\n\nmodule.exports = JsonSummaryReport;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/json.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = require('path'),\n    Writer = require('../util/file-writer'),\n    util = require('util'),\n    Report = require('./index');\n/**\n * a `Report` implementation that produces a coverage JSON object.\n *\n * Usage\n * -----\n *\n *      var report = require('istanbul').Report.create('json');\n *\n *\n * @class JsonReport\n * @extends Report\n * @module report\n * @constructor\n * @param {Object} opts optional\n * @param {String} [opts.dir] the directory in which to write the `coverage-final.json` file. Defaults to `process.cwd()`\n */\nfunction JsonReport(opts) {\n    this.opts = opts || {};\n    this.opts.dir = this.opts.dir || process.cwd();\n    this.opts.file = this.opts.file || this.getDefaultConfig().file;\n    this.opts.writer = this.opts.writer || null;\n}\nJsonReport.TYPE = 'json';\nutil.inherits(JsonReport, Report);\n\nReport.mix(JsonReport, {\n    synopsis: function () {\n        return 'prints the coverage object as JSON to a file';\n    },\n    getDefaultConfig: function () {\n        return {\n            file: 'coverage-final.json'\n        };\n    },\n    writeReport: function (collector, sync) {\n        var outputFile = path.resolve(this.opts.dir, this.opts.file),\n            writer = this.opts.writer || new Writer(sync),\n            that = this;\n\n        writer.on('done', function () { that.emit('done'); });\n        writer.writeFile(outputFile, function (contentWriter) {\n            var first = true;\n            contentWriter.println(\"{\");\n            collector.files().forEach(function (key) {\n                if (first) {\n                    first = false;\n                } else {\n                    contentWriter.println(\",\");\n                }\n                contentWriter.write(JSON.stringify(key));\n                contentWriter.write(\":\");\n                contentWriter.write(JSON.stringify(collector.fileCoverageFor(key)));\n            });\n            contentWriter.println(\"}\");\n        });\n        writer.done();\n    }\n});\n\nmodule.exports = JsonReport;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/lcov.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = require('path'),\n    util = require('util'),\n    mkdirp = require('mkdirp'),\n    Report = require('./index'),\n    LcovOnlyReport = require('./lcovonly'),\n    HtmlReport = require('./html');\n\n/**\n * a `Report` implementation that produces an LCOV coverage file and an associated HTML report from coverage objects.\n * The name and behavior of this report is designed to ease migration for projects that currently use `yuitest_coverage`\n *\n * Usage\n * -----\n *\n *      var report = require('istanbul').Report.create('lcov');\n *\n *\n * @class LcovReport\n * @extends Report\n * @module report\n * @constructor\n * @param {Object} opts optional\n * @param {String} [opts.dir] the directory in which to the `lcov.info` file.\n *  HTML files are written in a subdirectory called `lcov-report`. Defaults to `process.cwd()`\n */\nfunction LcovReport(opts) {\n    Report.call(this);\n    opts = opts || {};\n    var baseDir = path.resolve(opts.dir || process.cwd()),\n        htmlDir = path.resolve(baseDir, 'lcov-report');\n\n    mkdirp.sync(baseDir);\n    this.lcov = new LcovOnlyReport({ dir: baseDir, watermarks: opts.watermarks });\n    this.html = new HtmlReport({ dir: htmlDir, watermarks: opts.watermarks, sourceStore: opts.sourceStore});\n}\n\nLcovReport.TYPE = 'lcov';\nutil.inherits(LcovReport, Report);\n\nReport.mix(LcovReport, {\n    synopsis: function () {\n        return 'combined lcovonly and html report that generates an lcov.info file as well as HTML';\n    },\n    writeReport: function (collector, sync) {\n        var handler = this.handleDone.bind(this);\n        this.inProgress = 2;\n        this.lcov.on('done', handler);\n        this.html.on('done', handler);\n        this.lcov.writeReport(collector, sync);\n        this.html.writeReport(collector, sync);\n    },\n    handleDone: function () {\n        this.inProgress -= 1;\n        if (this.inProgress === 0) {\n            this.emit('done');\n        }\n    }\n});\n\nmodule.exports = LcovReport;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/lcovonly.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = require('path'),\n    Writer = require('../util/file-writer'),\n    util = require('util'),\n    Report = require('./index'),\n    utils = require('../object-utils');\n/**\n * a `Report` implementation that produces an LCOV coverage file from coverage objects.\n *\n * Usage\n * -----\n *\n *      var report = require('istanbul').Report.create('lcovonly');\n *\n *\n * @class LcovOnlyReport\n * @extends Report\n * @module report\n * @constructor\n * @param {Object} opts optional\n * @param {String} [opts.dir] the directory in which to the `lcov.info` file. Defaults to `process.cwd()`\n */\nfunction LcovOnlyReport(opts) {\n    this.opts = opts || {};\n    this.opts.dir = this.opts.dir || process.cwd();\n    this.opts.file = this.opts.file || this.getDefaultConfig().file;\n    this.opts.writer = this.opts.writer || null;\n}\nLcovOnlyReport.TYPE = 'lcovonly';\nutil.inherits(LcovOnlyReport, Report);\n\nReport.mix(LcovOnlyReport, {\n    synopsis: function () {\n        return 'lcov coverage report that can be consumed by the lcov tool';\n    },\n    getDefaultConfig: function () {\n        return { file: 'lcov.info' };\n    },\n    writeFileCoverage: function (writer, fc) {\n        var functions = fc.f,\n            functionMap = fc.fnMap,\n            lines = fc.l,\n            branches = fc.b,\n            branchMap = fc.branchMap,\n            summary = utils.summarizeFileCoverage(fc);\n\n        writer.println('TN:'); //no test name\n        writer.println('SF:' + fc.path);\n\n        Object.keys(functions).forEach(function (key) {\n            var meta = functionMap[key];\n            writer.println('FN:' + [ meta.line, meta.name ].join(','));\n        });\n        writer.println('FNF:' + summary.functions.total);\n        writer.println('FNH:' + summary.functions.covered);\n\n        Object.keys(functions).forEach(function (key) {\n            var stats = functions[key],\n                meta = functionMap[key];\n            writer.println('FNDA:' + [ stats, meta.name ].join(','));\n        });\n\n        Object.keys(lines).forEach(function (key) {\n            var stat = lines[key];\n            writer.println('DA:' + [ key, stat ].join(','));\n        });\n        writer.println('LF:' + summary.lines.total);\n        writer.println('LH:' + summary.lines.covered);\n\n        Object.keys(branches).forEach(function (key) {\n            var branchArray = branches[key],\n                meta = branchMap[key],\n                line = meta.line,\n                i = 0;\n            branchArray.forEach(function (b) {\n                writer.println('BRDA:' + [line, key, i, b].join(','));\n                i += 1;\n            });\n        });\n        writer.println('BRF:' + summary.branches.total);\n        writer.println('BRH:' + summary.branches.covered);\n        writer.println('end_of_record');\n    },\n\n    writeReport: function (collector, sync) {\n        var outputFile = path.resolve(this.opts.dir, this.opts.file),\n            writer = this.opts.writer || new Writer(sync),\n            that = this;\n        writer.on('done', function () { that.emit('done'); });\n        writer.writeFile(outputFile, function (contentWriter) {\n            collector.files().forEach(function (key) {\n                that.writeFileCoverage(contentWriter, collector.fileCoverageFor(key));\n            });\n        });\n        writer.done();\n    }\n});\n\nmodule.exports = LcovOnlyReport;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/none.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar util = require('util'),\n    Report = require('./index');\n\n/**\n * a `Report` implementation that does nothing. Use to specify that no reporting\n * is needed.\n *\n * Usage\n * -----\n *\n *      var report = require('istanbul').Report.create('none');\n *\n *\n * @class NoneReport\n * @extends Report\n * @module report\n * @constructor\n */\nfunction NoneReport() {\n    Report.call(this);\n}\n\nNoneReport.TYPE = 'none';\nutil.inherits(NoneReport, Report);\n\nReport.mix(NoneReport, {\n    synopsis: function () {\n        return 'Does nothing. Useful to override default behavior and suppress reporting entirely';\n    },\n    writeReport: function (/* collector, sync */) {\n        //noop\n        this.emit('done');\n    }\n});\n\nmodule.exports = NoneReport;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/teamcity.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = require('path'),\n    util = require('util'),\n    mkdirp = require('mkdirp'),\n    fs = require('fs'),\n    utils = require('../object-utils'),\n    Report = require('./index');\n\n/**\n * a `Report` implementation that produces system messages interpretable by TeamCity.\n *\n * Usage\n * -----\n *\n *      var report = require('istanbul').Report.create('teamcity');\n *\n * @class TeamcityReport\n * @extends Report\n * @module report\n * @constructor\n * @param {Object} opts optional\n * @param {String} [opts.dir] the directory in which to the text coverage report will be written, when writing to a file\n * @param {String} [opts.file] the filename for the report. When omitted, the report is written to console\n */\nfunction TeamcityReport(opts) {\n    Report.call(this);\n    opts = opts || {};\n    this.dir = opts.dir || process.cwd();\n    this.file = opts.file;\n    this.blockName = opts.blockName || this.getDefaultConfig().blockName;\n}\n\nTeamcityReport.TYPE = 'teamcity';\nutil.inherits(TeamcityReport, Report);\n\nfunction lineForKey(value, teamcityVar) {\n    return '##teamcity[buildStatisticValue key=\\'' + teamcityVar + '\\' value=\\'' + value + '\\']';\n}\n\nReport.mix(TeamcityReport, {\n    synopsis: function () {\n        return 'report with system messages that can be interpreted with TeamCity';\n    },\n    getDefaultConfig: function () {\n        return { file: null , blockName: 'Code Coverage Summary'};\n    },\n    writeReport: function (collector /*, sync */) {\n        var summaries = [],\n            finalSummary,\n            lines = [],\n            text;\n\n        collector.files().forEach(function (file) {\n            summaries.push(utils.summarizeFileCoverage(collector.fileCoverageFor(file)));\n        });\n\n        finalSummary = utils.mergeSummaryObjects.apply(null, summaries);\n\n        lines.push('');\n        lines.push('##teamcity[blockOpened name=\\''+ this.blockName +'\\']');\n\n        //Statements Covered\n        lines.push(lineForKey(finalSummary.statements.pct, 'CodeCoverageB'));\n\n        //Methods Covered\n        lines.push(lineForKey(finalSummary.functions.covered, 'CodeCoverageAbsMCovered'));\n        lines.push(lineForKey(finalSummary.functions.total, 'CodeCoverageAbsMTotal'));\n        lines.push(lineForKey(finalSummary.functions.pct, 'CodeCoverageM'));\n\n        //Lines Covered\n        lines.push(lineForKey(finalSummary.lines.covered, 'CodeCoverageAbsLCovered'));\n        lines.push(lineForKey(finalSummary.lines.total, 'CodeCoverageAbsLTotal'));\n        lines.push(lineForKey(finalSummary.lines.pct, 'CodeCoverageL'));\n\n        lines.push('##teamcity[blockClosed name=\\''+ this.blockName +'\\']');\n\n        text = lines.join('\\n');\n        if (this.file) {\n            mkdirp.sync(this.dir);\n            fs.writeFileSync(path.join(this.dir, this.file), text, 'utf8');\n        } else {\n            console.log(text);\n        }\n        this.emit('done');\n    }\n});\n\nmodule.exports = TeamcityReport;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/text-lcov.js":"var LcovOnly = require('./lcovonly'),\n  util = require('util');\n\n/**\n * a `Report` implementation that produces an LCOV coverage and prints it\n *  to standard out.\n *\n * Usage\n * -----\n *\n *      var report = require('istanbul').Report.create('text-lcov');\n *\n * @class TextLcov\n * @module report\n * @extends LcovOnly\n * @constructor\n * @param {Object} opts optional\n * @param {String} [opts.log] the method used to log to console.\n */\nfunction TextLcov(opts) {\n    var that = this;\n\n    LcovOnly.call(this);\n\n    this.opts = opts || {};\n    this.opts.log = this.opts.log || console.log;\n    this.opts.writer = {\n        println: function (ln) {\n            that.opts.log(ln);\n        }\n    };\n}\n\nTextLcov.TYPE = 'text-lcov';\nutil.inherits(TextLcov, LcovOnly);\n\nLcovOnly.super_.mix(TextLcov, {\n    writeReport: function (collector) {\n        var that = this,\n            writer = this.opts.writer;\n\n        collector.files().forEach(function (key) {\n            that.writeFileCoverage(writer, collector.fileCoverageFor(key));\n        });\n\n        this.emit('done');\n    }\n});\n\nmodule.exports = TextLcov;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/text-summary.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = require('path'),\n    util = require('util'),\n    mkdirp = require('mkdirp'),\n    defaults = require('./common/defaults'),\n    fs = require('fs'),\n    utils = require('../object-utils'),\n    Report = require('./index');\n\n/**\n * a `Report` implementation that produces text output for overall coverage in summary format.\n *\n * Usage\n * -----\n *\n *      var report = require('istanbul').Report.create('text-summary');\n *\n * @class TextSummaryReport\n * @extends Report\n * @module report\n * @constructor\n * @param {Object} opts optional\n * @param {String} [opts.dir] the directory in which to the text coverage report will be written, when writing to a file\n * @param {String} [opts.file] the filename for the report. When omitted, the report is written to console\n */\nfunction TextSummaryReport(opts) {\n    Report.call(this);\n    opts = opts || {};\n    this.dir = opts.dir || process.cwd();\n    this.file = opts.file;\n    this.watermarks = opts.watermarks || defaults.watermarks();\n}\n\nTextSummaryReport.TYPE = 'text-summary';\nutil.inherits(TextSummaryReport, Report);\n\nfunction lineForKey(summary, key, watermarks) {\n    var metrics = summary[key],\n        skipped,\n        result,\n        clazz = defaults.classFor(key, summary, watermarks);\n    key = key.substring(0, 1).toUpperCase() + key.substring(1);\n    if (key.length < 12) { key += '                   '.substring(0, 12 - key.length); }\n    result = [ key , ':', metrics.pct + '%', '(', metrics.covered + '/' + metrics.total, ')'].join(' ');\n    skipped = metrics.skipped;\n    if (skipped > 0) {\n        result += ', ' + skipped + ' ignored';\n    }\n    return defaults.colorize(result, clazz);\n}\n\nReport.mix(TextSummaryReport, {\n    synopsis: function () {\n        return 'text report that prints a coverage summary across all files, typically to console';\n    },\n    getDefaultConfig: function () {\n        return { file: null };\n    },\n    writeReport: function (collector /*, sync */) {\n        var summaries = [],\n            finalSummary,\n            lines = [],\n            watermarks = this.watermarks,\n            text;\n        collector.files().forEach(function (file) {\n            summaries.push(utils.summarizeFileCoverage(collector.fileCoverageFor(file)));\n        });\n        finalSummary = utils.mergeSummaryObjects.apply(null, summaries);\n        lines.push('');\n        lines.push('=============================== Coverage summary ===============================');\n        lines.push.apply(lines, [\n            lineForKey(finalSummary, 'statements', watermarks),\n            lineForKey(finalSummary, 'branches', watermarks),\n            lineForKey(finalSummary, 'functions', watermarks),\n            lineForKey(finalSummary, 'lines', watermarks)\n        ]);\n        lines.push('================================================================================');\n        text = lines.join('\\n');\n        if (this.file) {\n            mkdirp.sync(this.dir);\n            fs.writeFileSync(path.join(this.dir, this.file), text, 'utf8');\n        } else {\n            console.log(text);\n        }\n        this.emit('done');\n    }\n});\n\nmodule.exports = TextSummaryReport;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/report/text.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = require('path'),\n    mkdirp = require('mkdirp'),\n    util = require('util'),\n    fs = require('fs'),\n    defaults = require('./common/defaults'),\n    Report = require('./index'),\n    TreeSummarizer = require('../util/tree-summarizer'),\n    utils = require('../object-utils'),\n    PCT_COLS = 9,\n    MISSING_COL = 15,\n    TAB_SIZE = 1,\n    DELIM = ' |',\n    COL_DELIM = '-|';\n\n/**\n * a `Report` implementation that produces text output in a detailed table.\n *\n * Usage\n * -----\n *\n *      var report = require('istanbul').Report.create('text');\n *\n * @class TextReport\n * @extends Report\n * @module report\n * @constructor\n * @param {Object} opts optional\n * @param {String} [opts.dir] the directory in which to the text coverage report will be written, when writing to a file\n * @param {String} [opts.file] the filename for the report. When omitted, the report is written to console\n * @param {Number} [opts.maxCols] the max column width of the report. By default, the width of the report is adjusted based on the length of the paths\n *              to be reported.\n */\nfunction TextReport(opts) {\n    Report.call(this);\n    opts = opts || {};\n    this.dir = opts.dir || process.cwd();\n    this.file = opts.file;\n    this.summary = opts.summary;\n    this.maxCols = opts.maxCols || 0;\n    this.watermarks = opts.watermarks || defaults.watermarks();\n}\n\nTextReport.TYPE = 'text';\nutil.inherits(TextReport, Report);\n\nfunction padding(num, ch) {\n    var str = '',\n        i;\n    ch = ch || ' ';\n    for (i = 0; i < num; i += 1) {\n        str += ch;\n    }\n    return str;\n}\n\nfunction fill(str, width, right, tabs, clazz) {\n    tabs = tabs || 0;\n    str = String(str);\n\n    var leadingSpaces = tabs * TAB_SIZE,\n        remaining = width - leadingSpaces,\n        leader = padding(leadingSpaces),\n        fmtStr = '',\n        fillStr,\n        strlen = str.length;\n\n    if (remaining > 0) {\n        if (remaining >= strlen) {\n            fillStr = padding(remaining - strlen);\n            fmtStr = right ? fillStr + str : str + fillStr;\n        } else {\n            fmtStr = str.substring(strlen - remaining);\n            fmtStr = '... ' + fmtStr.substring(4);\n        }\n    }\n\n    fmtStr = defaults.colorize(fmtStr, clazz);\n    return leader + fmtStr;\n}\n\nfunction formatName(name, maxCols, level, clazz) {\n    return fill(name, maxCols, false, level, clazz);\n}\n\nfunction formatPct(pct, clazz, width) {\n    return fill(pct, width || PCT_COLS, true, 0, clazz);\n}\n\nfunction nodeName(node) {\n    return node.displayShortName() || 'All files';\n}\n\nfunction tableHeader(maxNameCols) {\n    var elements = [];\n    elements.push(formatName('File', maxNameCols, 0));\n    elements.push(formatPct('% Stmts'));\n    elements.push(formatPct('% Branch'));\n    elements.push(formatPct('% Funcs'));\n    elements.push(formatPct('% Lines'));\n    elements.push(formatPct('Uncovered Lines', undefined, MISSING_COL));\n    return elements.join(' |') + ' |';\n}\n\nfunction collectMissingLines(kind, linesCovered) {\n  var missingLines = [];\n\n  if (kind !== 'file') {\n      return [];\n  }\n\n  Object.keys(linesCovered).forEach(function (key) {\n      if (!linesCovered[key]) {\n          missingLines.push(key);\n      }\n  });\n\n  return missingLines;\n}\n\nfunction tableRow(node, maxNameCols, level, watermarks) {\n    var name = nodeName(node),\n        statements = node.metrics.statements.pct,\n        branches = node.metrics.branches.pct,\n        functions = node.metrics.functions.pct,\n        lines = node.metrics.lines.pct,\n        missingLines = collectMissingLines(node.kind, node.metrics.linesCovered),\n        elements = [];\n\n    elements.push(formatName(name, maxNameCols, level, defaults.classFor('statements', node.metrics, watermarks)));\n    elements.push(formatPct(statements, defaults.classFor('statements', node.metrics, watermarks)));\n    elements.push(formatPct(branches, defaults.classFor('branches', node.metrics, watermarks)));\n    elements.push(formatPct(functions, defaults.classFor('functions', node.metrics, watermarks)));\n    elements.push(formatPct(lines, defaults.classFor('lines', node.metrics, watermarks)));\n    elements.push(formatPct(missingLines.join(','), 'low', MISSING_COL));\n\n    return elements.join(DELIM) + DELIM;\n}\n\nfunction findNameWidth(node, level, last) {\n    last = last || 0;\n    level = level || 0;\n    var idealWidth = TAB_SIZE * level + nodeName(node).length;\n    if (idealWidth > last) {\n        last = idealWidth;\n    }\n    node.children.forEach(function (child) {\n        last = findNameWidth(child, level + 1, last);\n    });\n    return last;\n}\n\nfunction makeLine(nameWidth) {\n    var name = padding(nameWidth, '-'),\n        pct = padding(PCT_COLS, '-'),\n        elements = [];\n\n    elements.push(name);\n    elements.push(pct);\n    elements.push(pct);\n    elements.push(pct);\n    elements.push(pct);\n    elements.push(padding(MISSING_COL, '-'));\n    return elements.join(COL_DELIM) + COL_DELIM;\n}\n\nfunction walk(node, nameWidth, array, level, watermarks) {\n    var line;\n    if (level === 0) {\n        line = makeLine(nameWidth);\n        array.push(line);\n        array.push(tableHeader(nameWidth));\n        array.push(line);\n    } else {\n        array.push(tableRow(node, nameWidth, level, watermarks));\n    }\n    node.children.forEach(function (child) {\n        walk(child, nameWidth, array, level + 1, watermarks);\n    });\n    if (level === 0) {\n        array.push(line);\n        array.push(tableRow(node, nameWidth, level, watermarks));\n        array.push(line);\n    }\n}\n\nReport.mix(TextReport, {\n    synopsis: function () {\n        return 'text report that prints a coverage line for every file, typically to console';\n    },\n    getDefaultConfig: function () {\n        return { file: null, maxCols: 0 };\n    },\n    writeReport: function (collector /*, sync */) {\n        var summarizer = new TreeSummarizer(),\n            tree,\n            root,\n            nameWidth,\n            statsWidth = 4 * (PCT_COLS + 2) + MISSING_COL,\n            maxRemaining,\n            strings = [],\n            text;\n\n        collector.files().forEach(function (key) {\n            summarizer.addFileCoverageSummary(key, utils.summarizeFileCoverage(\n                collector.fileCoverageFor(key)\n            ));\n        });\n        tree = summarizer.getTreeSummary();\n        root = tree.root;\n        nameWidth = findNameWidth(root);\n        if (this.maxCols > 0) {\n            maxRemaining = this.maxCols - statsWidth - 2;\n            if (nameWidth > maxRemaining) {\n                nameWidth = maxRemaining;\n            }\n        }\n        walk(root, nameWidth, strings, 0, this.watermarks);\n        text = strings.join('\\n') + '\\n';\n        if (this.file) {\n            mkdirp.sync(this.dir);\n            fs.writeFileSync(path.join(this.dir, this.file), text, 'utf8');\n        } else {\n            console.log(text);\n        }\n        this.emit('done');\n    }\n});\n\nmodule.exports = TextReport;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/command/check-coverage.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar nopt = require('nopt'),\n    path = require('path'),\n    fs = require('fs'),\n    Collector = require('../collector'),\n    formatOption = require('../util/help-formatter').formatOption,\n    util = require('util'),\n    utils = require('../object-utils'),\n    filesFor = require('../util/file-matcher').filesFor,\n    Command = require('./index'),\n    configuration = require('../config');\n\nfunction isAbsolute(file) {\n    if (path.isAbsolute) {\n        return path.isAbsolute(file);\n    }\n\n    return path.resolve(file) === path.normalize(file);\n}\n\nfunction CheckCoverageCommand() {\n    Command.call(this);\n}\n\nfunction removeFiles(covObj, root, files) {\n    var filesObj = {},\n        obj = {};\n\n    // Create lookup table.\n    files.forEach(function (file) {\n        filesObj[file] = true;\n    });\n\n    Object.keys(covObj).forEach(function (key) {\n        // Exclude keys will always be relative, but covObj keys can be absolute or relative\n        var excludeKey = isAbsolute(key) ? path.relative(root, key) : key;\n        // Also normalize for files that start with `./`, etc.\n        excludeKey = path.normalize(excludeKey);\n        if (filesObj[excludeKey] !== true) {\n            obj[key] = covObj[key];\n        }\n    });\n\n    return obj;\n}\n\nCheckCoverageCommand.TYPE = 'check-coverage';\nutil.inherits(CheckCoverageCommand, Command);\n\nCommand.mix(CheckCoverageCommand, {\n    synopsis: function () {\n        return \"checks overall/per-file coverage against thresholds from coverage JSON files. Exits 1 if thresholds are not met, 0 otherwise\";\n    },\n\n    usage: function () {\n        console.error('\\nUsage: ' + this.toolName() + ' ' + this.type() + ' <options> [<include-pattern>]\\n\\nOptions are:\\n\\n' +\n            [\n                formatOption('--statements <threshold>', 'global statement coverage threshold'),\n                formatOption('--functions <threshold>', 'global function coverage threshold'),\n                formatOption('--branches <threshold>', 'global branch coverage threshold'),\n                formatOption('--lines <threshold>', 'global line coverage threshold')\n            ].join('\\n\\n') + '\\n');\n\n        console.error('\\n\\n');\n\n        console.error('Thresholds, when specified as a positive number are taken to be the minimum percentage required.');\n        console.error('When a threshold is specified as a negative number it represents the maximum number of uncovered entities allowed.\\n');\n        console.error('For example, --statements 90 implies minimum statement coverage is 90%.');\n        console.error('             --statements -10 implies that no more than 10 uncovered statements are allowed\\n');\n        console.error('Per-file thresholds can be specified via a configuration file.\\n');\n        console.error('<include-pattern> is a glob pattern that can be used to select one or more coverage files ' +\n            'for merge. This defaults to \"**/coverage*.json\"');\n\n        console.error('\\n');\n    },\n\n    run: function (args, callback) {\n\n        var template = {\n                config: path,\n                root: path,\n                statements: Number,\n                lines: Number,\n                branches: Number,\n                functions: Number,\n                verbose: Boolean\n            },\n            opts = nopt(template, { v : '--verbose' }, args, 0),\n            // Translate to config opts.\n            config = configuration.loadFile(opts.config, {\n                verbose: opts.verbose,\n                check: {\n                    global: {\n                        statements: opts.statements,\n                        lines: opts.lines,\n                        branches: opts.branches,\n                        functions: opts.functions\n                    }\n                }\n            }),\n            includePattern = '**/coverage*.json',\n            root,\n            collector = new Collector(),\n            errors = [];\n\n        if (opts.argv.remain.length > 0) {\n            includePattern = opts.argv.remain[0];\n        }\n\n        root = opts.root || process.cwd();\n        filesFor({\n            root: root,\n            includes: [ includePattern ]\n        }, function (err, files) {\n            if (err) { throw err; }\n            if (files.length === 0) {\n               return callback('ERROR: No coverage files found.');\n            }\n            files.forEach(function (file) {\n                var coverageObject = JSON.parse(fs.readFileSync(file, 'utf8'));\n                collector.add(coverageObject);\n            });\n            var thresholds = {\n                global: {\n                    statements: config.check.global.statements || 0,\n                    branches: config.check.global.branches || 0,\n                    lines: config.check.global.lines || 0,\n                    functions: config.check.global.functions || 0,\n                    excludes: config.check.global.excludes || []\n                },\n                each: {\n                    statements: config.check.each.statements || 0,\n                    branches: config.check.each.branches || 0,\n                    lines: config.check.each.lines || 0,\n                    functions: config.check.each.functions || 0,\n                    excludes: config.check.each.excludes || []\n                }\n            },\n                rawCoverage = collector.getFinalCoverage(),\n                globalResults = utils.summarizeCoverage(removeFiles(rawCoverage, root, thresholds.global.excludes)),\n                eachResults = removeFiles(rawCoverage, root, thresholds.each.excludes);\n\n            // Summarize per-file results and mutate original results.\n            Object.keys(eachResults).forEach(function (key) {\n                eachResults[key] = utils.summarizeFileCoverage(eachResults[key]);\n            });\n\n            if (config.verbose) {\n                console.log('Compare actuals against thresholds');\n                console.log(JSON.stringify({ global: globalResults, each: eachResults, thresholds: thresholds }, undefined, 4));\n            }\n\n            function check(name, thresholds, actuals) {\n                [\n                    \"statements\",\n                    \"branches\",\n                    \"lines\",\n                    \"functions\"\n                ].forEach(function (key) {\n                    var actual = actuals[key].pct,\n                        actualUncovered = actuals[key].total - actuals[key].covered,\n                        threshold = thresholds[key];\n\n                    if (threshold < 0) {\n                        if (threshold * -1 < actualUncovered) {\n                            errors.push('ERROR: Uncovered count for ' + key + ' (' + actualUncovered +\n                                ') exceeds ' + name + ' threshold (' + -1 * threshold + ')');\n                        }\n                    } else {\n                        if (actual < threshold) {\n                            errors.push('ERROR: Coverage for ' + key + ' (' + actual +\n                                '%) does not meet ' + name + ' threshold (' + threshold + '%)');\n                        }\n                    }\n                });\n            }\n\n            check(\"global\", thresholds.global, globalResults);\n\n            Object.keys(eachResults).forEach(function (key) {\n                check(\"per-file\" + \" (\" + key + \") \", thresholds.each, eachResults[key]);\n            });\n\n            return callback(errors.length === 0 ? null : errors.join(\"\\n\"));\n        });\n    }\n});\n\nmodule.exports = CheckCoverageCommand;\n\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/collector.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\"use strict\";\nvar MemoryStore = require('./store/memory'),\n    utils = require('./object-utils');\n\n/**\n * a mechanism to merge multiple coverage objects into one. Handles the use case\n * of overlapping coverage information for the same files in multiple coverage\n * objects and does not double-count in this situation. For example, if\n * you pass the same coverage object multiple times, the final merged object will be\n * no different that any of the objects passed in (except for execution counts).\n *\n * The `Collector` is built for scale to handle thousands of coverage objects.\n * By default, all processing is done in memory since the common use-case is of\n * one or a few coverage objects. You can work around memory\n * issues by passing in a `Store` implementation that stores temporary computations\n * on disk (the `tmp` store, for example).\n *\n * The `getFinalCoverage` method returns an object with merged coverage information\n * and is provided as a convenience for implementors working with coverage information\n * that can fit into memory. Reporters, in the interest of generality, should *not* use this method for\n * creating reports.\n *\n * Usage\n * -----\n *\n *      var collector = new require('istanbul').Collector();\n *\n *      files.forEach(function (f) {\n *          //each coverage object can have overlapping information about multiple files\n *          collector.add(JSON.parse(fs.readFileSync(f, 'utf8')));\n *      });\n *\n *      collector.files().forEach(function(file) {\n *          var fileCoverage = collector.fileCoverageFor(file);\n *          console.log('Coverage for ' + file + ' is:' + JSON.stringify(fileCoverage));\n *      });\n *\n *      // convenience method: do not use this when dealing with a large number of files\n *      var finalCoverage = collector.getFinalCoverage();\n *\n * @class Collector\n * @module main\n * @constructor\n * @param {Object} options Optional. Configuration options.\n * @param {Store} options.store - an implementation of `Store` to use for temporary\n *      calculations.\n */\nfunction Collector(options) {\n    options = options || {};\n    this.store = options.store || new MemoryStore();\n}\n\nCollector.prototype = {\n    /**\n     * adds a coverage object to the collector.\n     *\n     * @method add\n     * @param {Object} coverage the coverage object.\n     * @param {String} testName Optional. The name of the test used to produce the object.\n     *      This is currently not used.\n     */\n    add: function (coverage /*, testName */) {\n        var store = this.store;\n        Object.keys(coverage).forEach(function (key) {\n            var fileCoverage = coverage[key];\n            if (store.hasKey(key)) {\n                store.setObject(key, utils.mergeFileCoverage(fileCoverage, store.getObject(key)));\n            } else {\n                store.setObject(key, fileCoverage);\n            }\n        });\n    },\n    /**\n     * returns a list of unique file paths for which coverage information has been added.\n     * @method files\n     * @return {Array} an array of file paths for which coverage information is present.\n     */\n    files: function () {\n        return this.store.keys();\n    },\n    /**\n     * return file coverage information for a single file\n     * @method fileCoverageFor\n     * @param {String} fileName the path for the file for which coverage information is\n     *      required. Must be one of the values returned in the `files()` method.\n     * @return {Object} the coverage information for the specified file.\n     */\n    fileCoverageFor: function (fileName) {\n        var ret = this.store.getObject(fileName);\n        utils.addDerivedInfoForFile(ret);\n        return ret;\n    },\n    /**\n     * returns file coverage information for all files. This has the same format as\n     * any of the objects passed in to the `add` method. The number of keys in this\n     * object will be a superset of all keys found in the objects passed to `add()`\n     * @method getFinalCoverage\n     * @return {Object} the merged coverage information\n     */\n    getFinalCoverage: function () {\n        var ret = {},\n            that = this;\n        this.files().forEach(function (file) {\n            ret[file] = that.fileCoverageFor(file);\n        });\n        return ret;\n    },\n    /**\n     * disposes this collector and reclaims temporary resources used in the\n     * computation. Calls `dispose()` on the underlying store.\n     * @method dispose\n     */\n    dispose: function () {\n        this.store.dispose();\n    }\n};\n\nmodule.exports = Collector;","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/util/help-formatter.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar OPT_PREFIX = \"      \",\n    OPT_START = OPT_PREFIX.length,\n    TEXT_START = 14,\n    STOP = 80,\n    wrap = require('wordwrap')(TEXT_START, STOP),\n    paraWrap = require('wordwrap')(1, STOP);\n\nfunction formatPara(text) {\n    return paraWrap(text);\n}\n\nfunction formatOption(option, helpText) {\n    var formattedText = wrap(helpText);\n\n    if (option.length > TEXT_START - OPT_START - 2) {\n        return OPT_PREFIX + option + '\\n' + formattedText;\n    } else {\n        return OPT_PREFIX + option + formattedText.substring((OPT_PREFIX + option).length);\n    }\n}\n\nmodule.exports = {\n    formatPara: formatPara,\n    formatOption: formatOption\n};","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/util/file-matcher.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar async = require('async'),\n    glob = require('glob'),\n    fs = require('fs'),\n    path = require('path'),\n    seq = 0;\n\nfunction filesFor(options, callback) {\n    if (!callback && typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n\n    var root = options.root,\n        includes = options.includes,\n        excludes = options.excludes,\n        realpath = options.realpath,\n        relative = options.relative,\n        opts;\n\n    root = root || process.cwd();\n    includes = includes && Array.isArray(includes) ? includes : [ '**/*.js' ];\n    excludes = excludes && Array.isArray(excludes) ? excludes : [ '**/node_modules/**' ];\n\n    opts = { cwd: root, nodir: true, ignore: excludes };\n    seq += 1;\n    opts['x' + seq + new Date().getTime()] = true; //cache buster for minimatch cache bug\n    glob(includes.join(' '), opts, function (err, files) {\n        if (err) { return callback(err); }\n        if (relative) { return callback(err, files); }\n\n        if (!realpath) {\n            files = files.map(function (file) { return path.resolve(root, file); });\n            return callback(err, files);\n        }\n\n        var realPathCache = module.constructor._realpathCache || {};\n\n        async.map(files, function (file, done) {\n            fs.realpath(path.resolve(root, file), realPathCache, done);\n        }, callback);\n    });\n}\n\nfunction matcherFor(options, callback) {\n\n    if (!callback && typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n    options.relative = false; //force absolute paths\n    options.realpath = true; //force real paths (to match Node.js module paths)\n\n    filesFor(options, function (err, files) {\n        var fileMap = {},\n            matchFn;\n        if (err) { return callback(err); }\n        files.forEach(function (file) { fileMap[file] = true; });\n\n        matchFn = function (file) { return fileMap[file]; };\n        matchFn.files = Object.keys(fileMap);\n        return callback(null, matchFn);\n    });\n}\n\nmodule.exports = {\n    filesFor: filesFor,\n    matcherFor: matcherFor\n};\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/config.js":"/*\n Copyright (c) 2013, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar path = require('path'),\n    fs = require('fs'),\n    existsSync = fs.existsSync || path.existsSync,\n    CAMEL_PATTERN = /([a-z])([A-Z])/g,\n    YML_PATTERN = /\\.ya?ml$/,\n    yaml = require('js-yaml'),\n    defaults = require('./report/common/defaults');\n\nfunction defaultConfig(includeBackCompatAttrs) {\n    var ret = {\n        verbose: false,\n        instrumentation: {\n            root: '.',\n            extensions: ['.js'],\n            'default-excludes': true,\n            excludes: [],\n            'embed-source': false,\n            variable: '__coverage__',\n            compact: true,\n            'preserve-comments': false,\n            'complete-copy': false,\n            'save-baseline': false,\n            'baseline-file': './coverage/coverage-baseline.json',\n            'include-all-sources': false,\n            'include-pid': false,\n            'es-modules': false\n        },\n        reporting: {\n            print: 'summary',\n            reports: [ 'lcov' ],\n            dir: './coverage'\n        },\n        hooks: {\n            'hook-run-in-context': false,\n            'post-require-hook': null,\n            'handle-sigint': false\n        },\n        check: {\n            global: {\n                statements: 0,\n                lines: 0,\n                branches: 0,\n                functions: 0,\n                excludes: [] // Currently list of files (root + path). For future, extend to patterns.\n            },\n            each: {\n                statements: 0,\n                lines: 0,\n                branches: 0,\n                functions: 0,\n                excludes: []\n            }\n        }\n    };\n    ret.reporting.watermarks = defaults.watermarks();\n    ret.reporting['report-config'] = defaults.defaultReportConfig();\n\n    if (includeBackCompatAttrs) {\n        ret.instrumentation['preload-sources'] = false;\n    }\n\n    return ret;\n}\n\nfunction dasherize(word) {\n    return word.replace(CAMEL_PATTERN, function (match, lch, uch) {\n        return lch + '-' + uch.toLowerCase();\n    });\n}\nfunction isScalar(v) {\n    if (v === null) { return true; }\n    return v !== undefined && !Array.isArray(v) && typeof v !== 'object';\n}\n\nfunction isObject(v) {\n    return typeof v === 'object' && v !== null && !Array.isArray(v);\n}\n\nfunction mergeObjects(explicit, template) {\n\n    var ret = {};\n\n    Object.keys(template).forEach(function (k) {\n        var v1 = template[k],\n            v2 = explicit[k];\n\n        if (Array.isArray(v1)) {\n            ret[k] = Array.isArray(v2) && v2.length > 0 ? v2 : v1;\n        } else if (isObject(v1)) {\n            v2 = isObject(v2) ? v2 : {};\n            ret[k] = mergeObjects(v2, v1);\n        } else {\n            ret[k] = isScalar(v2) ? v2 : v1;\n        }\n    });\n    return ret;\n}\n\nfunction mergeDefaults(explicit, implicit) {\n    return mergeObjects(explicit || {}, implicit);\n}\n\nfunction addMethods() {\n    var args = Array.prototype.slice.call(arguments),\n        cons = args.shift();\n\n    args.forEach(function (arg) {\n        var method = arg,\n            property = dasherize(arg);\n        cons.prototype[method] = function () {\n            return this.config[property];\n        };\n    });\n}\n\n/**\n * Object that returns instrumentation options\n * @class InstrumentOptions\n * @module config\n * @constructor\n * @param config the instrumentation part of the config object\n */\nfunction InstrumentOptions(config) {\n    if (config['preload-sources']) {\n        console.error('The preload-sources option is deprecated, please use include-all-sources instead.');\n        config['include-all-sources'] = config['preload-sources'];\n    }\n    this.config = config;\n}\n\n/**\n * returns if default excludes should be turned on. Used by the `cover` command.\n * @method defaultExcludes\n * @return {Boolean} true if default excludes should be turned on\n */\n/**\n * returns if non-JS files should be copied during instrumentation. Used by the\n * `instrument` command.\n * @method completeCopy\n * @return {Boolean} true if non-JS files should be copied\n */\n/**\n * returns if the source should be embedded in the instrumented code. Used by the\n * `instrument` command.\n * @method embedSource\n * @return {Boolean} true if the source should be embedded in the instrumented code\n */\n/**\n * the coverage variable name to use. Used by the `instrument` command.\n * @method variable\n * @return {String} the coverage variable name to use\n */\n/**\n * returns if the output should be compact JS. Used by the `instrument` command.\n * @method compact\n * @return {Boolean} true if the output should be compact\n */\n/**\n * returns if comments should be preserved in the generated JS. Used by the\n * `cover` and `instrument` commands.\n * @method preserveComments\n * @return {Boolean} true if comments should be preserved in the generated JS\n */\n/**\n * returns if a zero-coverage baseline file should be written as part of\n * instrumentation. This allows reporting to display numbers for files that have\n * no tests. Used by the  `instrument` command.\n * @method saveBaseline\n * @return {Boolean} true if a baseline coverage file should be written.\n */\n/**\n * Sets the baseline coverage filename. Used by the  `instrument` command.\n * @method baselineFile\n * @return {String} the name of the baseline coverage file.\n */\n/**\n * returns if comments the JS to instrument contains es6 Module syntax.\n * @method esModules\n * @return {Boolean} true if code contains es6 import/export statements.\n */\n/**\n * returns if the coverage filename should include the PID. Used by the  `instrument` command.\n * @method includePid\n * @return {Boolean} true to include pid in coverage filename.\n */\n\n\naddMethods(InstrumentOptions,\n    'extensions', 'defaultExcludes', 'completeCopy',\n    'embedSource', 'variable', 'compact', 'preserveComments',\n    'saveBaseline', 'baselineFile', 'esModules',\n    'includeAllSources', 'includePid');\n\n/**\n * returns the root directory used by istanbul which is typically the root of the\n * source tree. Used by the `cover` and `report` commands.\n * @method root\n * @return {String} the root directory used by istanbul.\n */\nInstrumentOptions.prototype.root = function () { return path.resolve(this.config.root); };\n/**\n * returns an array of glob patterns that should be excluded for instrumentation.\n * Used by the `instrument` and `cover` commands.\n * @method excludes\n * @return {Array} an array of glob patterns that should be excluded for\n *  instrumentation.\n */\nInstrumentOptions.prototype.excludes = function (excludeTests) {\n    var defs;\n    if (this.defaultExcludes()) {\n        defs = [ '**/node_modules/**' ];\n        if (excludeTests) {\n            defs = defs.concat(['**/test/**', '**/tests/**']);\n        }\n        return defs.concat(this.config.excludes);\n    }\n    return this.config.excludes;\n};\n\n/**\n * Object that returns reporting options\n * @class ReportingOptions\n * @module config\n * @constructor\n * @param config the reporting part of the config object\n */\nfunction ReportingOptions(config) {\n    this.config = config;\n}\n\n/**\n * returns the kind of information to be printed on the console. May be one\n * of `summary`, `detail`, `both` or `none`. Used by the\n * `cover` command.\n * @method print\n * @return {String} the kind of information to print to the console at the end\n * of the `cover` command execution.\n */\n/**\n * returns a list of reports that should be generated at the end of a run. Used\n * by the `cover` and `report` commands.\n * @method reports\n * @return {Array} an array of reports that should be produced\n */\n/**\n * returns the directory under which reports should be generated. Used by the\n * `cover` and `report` commands.\n *\n * @method dir\n * @return {String} the directory under which reports should be generated.\n */\n/**\n * returns an object that has keys that are report format names and values that are objects\n * containing detailed configuration for each format. Running `istanbul help config`\n * will give you all the keys per report format that can be overridden.\n * Used by the `cover` and `report` commands.\n * @method reportConfig\n * @return {Object} detailed report configuration per report format.\n */\naddMethods(ReportingOptions, 'print', 'reports', 'dir', 'reportConfig');\n\nfunction isInvalidMark(v, key) {\n    var prefix = 'Watermark for [' + key + '] :';\n\n    if (v.length !== 2) {\n        return prefix + 'must be an array of length 2';\n    }\n    v[0] = Number(v[0]);\n    v[1] = Number(v[1]);\n\n    if (isNaN(v[0]) || isNaN(v[1])) {\n        return prefix + 'must have valid numbers';\n    }\n    if (v[0] < 0 || v[1] < 0) {\n        return prefix + 'must be positive numbers';\n    }\n    if (v[1] > 100) {\n        return prefix + 'cannot exceed 100';\n    }\n    if (v[1] <= v[0]) {\n        return prefix + 'low must be less than high';\n    }\n    return null;\n}\n\n/**\n * returns the low and high watermarks to be used to designate whether coverage\n * is `low`, `medium` or `high`. Statements, functions, branches and lines can\n * have independent watermarks. These are respected by all reports\n * that color for low, medium and high coverage. See the default configuration for exact syntax\n * using `istanbul help config`. Used by the `cover` and `report` commands.\n *\n * @method watermarks\n * @return {Object} an object containing low and high watermarks for statements,\n *  branches, functions and lines.\n */\nReportingOptions.prototype.watermarks = function () {\n    var v = this.config.watermarks,\n        defs = defaults.watermarks(),\n        ret = {};\n\n    Object.keys(defs).forEach(function (k) {\n        var mark = v[k], //it will already be a non-zero length array because of the way the merge works\n            message = isInvalidMark(mark, k);\n        if (message) {\n            console.error(message);\n            ret[k] = defs[k];\n        } else {\n            ret[k] = mark;\n        }\n    });\n    return ret;\n};\n\n/**\n * Object that returns hook options. Note that istanbul does not provide an\n * option to hook `require`. This is always done by the `cover` command.\n * @class HookOptions\n * @module config\n * @constructor\n * @param config the hooks part of the config object\n */\nfunction HookOptions(config) {\n    this.config = config;\n}\n\n/**\n * returns if `vm.runInThisContext` needs to be hooked, in addition to the standard\n * `require` hooks added by istanbul. This should be true for code that uses\n * RequireJS for example. Used by the `cover` command.\n * @method hookRunInContext\n * @return {Boolean} true if `vm.runInThisContext` needs to be hooked for coverage\n */\n/**\n * returns a path to JS file or a dependent module that should be used for\n * post-processing files after they have been required. See the `yui-istanbul` module for\n * an example of a post-require hook. This particular hook modifies the yui loader when\n * that file is required to add istanbul interceptors. Use by the `cover` command\n *\n * @method postRequireHook\n * @return {String} a path to a JS file or the name of a node module that needs\n * to be used as a `require` post-processor\n */\n/**\n * returns if istanbul needs to add a SIGINT (control-c, usually) handler to\n * save coverage information. Useful for getting code coverage out of processes\n * that run forever and need a SIGINT to terminate.\n * @method handleSigint\n * @return {Boolean} true if SIGINT needs to be hooked to write coverage information\n */\n\naddMethods(HookOptions, 'hookRunInContext', 'postRequireHook', 'handleSigint');\n\n/**\n * represents the istanbul configuration and provides sub-objects that can\n * return instrumentation, reporting and hook options respectively.\n * Usage\n * -----\n *\n *      var configObj = require('istanbul').config.loadFile();\n *\n *      console.log(configObj.reporting.reports());\n *\n * @class Configuration\n * @module config\n * @param {Object} obj  the base object to use as the configuration\n * @param {Object} overrides optional - override attributes that are merged into\n *  the base config\n * @constructor\n */\nfunction Configuration(obj, overrides) {\n\n    var config = mergeDefaults(obj, defaultConfig(true));\n    if (isObject(overrides)) {\n        config = mergeDefaults(overrides, config);\n    }\n    if (config.verbose) {\n        console.error('Using configuration');\n        console.error('-------------------');\n        console.error(yaml.safeDump(config, { indent: 4, flowLevel: 3 }));\n        console.error('-------------------\\n');\n    }\n    this.verbose = config.verbose;\n    this.instrumentation = new InstrumentOptions(config.instrumentation);\n    this.reporting = new ReportingOptions(config.reporting);\n    this.hooks = new HookOptions(config.hooks);\n    this.check = config.check; // Pass raw config sub-object.\n}\n\n/**\n * true if verbose logging is required\n * @property verbose\n * @type Boolean\n */\n/**\n * instrumentation options\n * @property instrumentation\n * @type InstrumentOptions\n */\n/**\n * reporting options\n * @property reporting\n * @type ReportingOptions\n */\n/**\n * hook options\n * @property hooks\n * @type HookOptions\n */\n\n\nfunction loadFile(file, overrides) {\n    var defaultConfigFile = path.resolve('.istanbul.yml'),\n        configObject;\n\n    if (file) {\n        if (!existsSync(file)) {\n            throw new Error('Invalid configuration file specified:' + file);\n        }\n    } else {\n        if (existsSync(defaultConfigFile)) {\n            file = defaultConfigFile;\n        }\n    }\n\n    if (file) {\n        if (overrides && overrides.verbose === true) {\n            console.error('Loading config: ' + file);\n        }\n        configObject = file.match(YML_PATTERN) ?\n            yaml.safeLoad(fs.readFileSync(file, 'utf8'), { filename: file }) :\n            require(path.resolve(file));\n    }\n\n    return new Configuration(configObject, overrides);\n}\n\nfunction loadObject(obj, overrides) {\n    return new Configuration(obj, overrides);\n}\n\n/**\n * methods to load the configuration object.\n * Usage\n * -----\n *\n *      var config = require('istanbul').config,\n *          configObj = config.loadFile();\n *\n *      console.log(configObj.reporting.reports());\n *\n * @class Config\n * @module main\n * @static\n */\nmodule.exports = {\n    /**\n     * loads the specified configuration file with optional overrides. Throws\n     * when a file is specified and it is not found.\n     * @method loadFile\n     * @static\n     * @param {String} file the file to load. If falsy, the default config file, if present, is loaded.\n     *  If not a default config is used.\n     * @param {Object} overrides - an object with override keys that are merged into the\n     *  config object loaded\n     * @return {Configuration} the config object with overrides applied\n     */\n    loadFile: loadFile,\n    /**\n     * loads the specified configuration object with optional overrides.\n     * @method loadObject\n     * @static\n     * @param {Object} obj the object to use as the base configuration.\n     * @param {Object} overrides - an object with override keys that are merged into the\n     *  config object\n     * @return {Configuration} the config object with overrides applied\n     */\n    loadObject: loadObject,\n    /**\n     * returns the default configuration object. Note that this is a plain object\n     * and not a `Configuration` instance.\n     * @method defaultConfig\n     * @static\n     * @return {Object} an object that represents the default config\n     */\n    defaultConfig: defaultConfig\n};\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/command/cover.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar runWithCover = require('./common/run-with-cover'),\n    util = require('util'),\n    Command = require('./index');\n\nfunction CoverCommand() {\n    Command.call(this);\n}\n\nCoverCommand.TYPE = 'cover';\nutil.inherits(CoverCommand, Command);\n\nCommand.mix(CoverCommand, {\n    synopsis: function () {\n        return \"transparently adds coverage information to a node command. Saves coverage.json and reports at the end of execution\";\n    },\n\n    usage: function () {\n        runWithCover.usage(this.toolName(), this.type());\n    },\n\n    run: function (args, callback) {\n        runWithCover.run(args, this.type(), true, callback);\n    }\n});\n\n\nmodule.exports = CoverCommand;\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/command/common/run-with-cover.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar Module = require('module'),\n    path = require('path'),\n    fs = require('fs'),\n    nopt = require('nopt'),\n    which = require('which'),\n    mkdirp = require('mkdirp'),\n    existsSync = fs.existsSync || path.existsSync,\n    inputError = require('../../util/input-error'),\n    matcherFor = require('../../util/file-matcher').matcherFor,\n    Instrumenter = require('../../instrumenter'),\n    Collector = require('../../collector'),\n    formatOption = require('../../util/help-formatter').formatOption,\n    hook = require('../../hook'),\n    Reporter = require('../../reporter'),\n    resolve = require('resolve'),\n    configuration = require('../../config');\n\nfunction usage(arg0, command) {\n\n    console.error('\\nUsage: ' + arg0 + ' ' + command + ' [<options>] <executable-js-file-or-command> [-- <arguments-to-jsfile>]\\n\\nOptions are:\\n\\n'\n        + [\n            formatOption('--config <path-to-config>', 'the configuration file to use, defaults to .istanbul.yml'),\n            formatOption('--root <path> ', 'the root path to look for files to instrument, defaults to .'),\n            formatOption('-x <exclude-pattern> [-x <exclude-pattern>]', 'one or more glob patterns e.g. \"**/vendor/**\"'),\n            formatOption('-i <include-pattern> [-i <include-pattern>]', 'one or more glob patterns e.g. \"**/*.js\"'),\n            formatOption('--[no-]default-excludes', 'apply default excludes [ **/node_modules/**, **/test/**, **/tests/** ], defaults to true'),\n            formatOption('--hook-run-in-context', 'hook vm.runInThisContext in addition to require (supports RequireJS), defaults to false'),\n            formatOption('--post-require-hook <file> | <module>', 'JS module that exports a function for post-require processing'),\n            formatOption('--report <format> [--report <format>] ', 'report format, defaults to lcov (= lcov.info + HTML)'),\n            formatOption('--dir <report-dir>', 'report directory, defaults to ./coverage'),\n            formatOption('--print <type>', 'type of report to print to console, one of summary (default), detail, both or none'),\n            formatOption('--verbose, -v', 'verbose mode'),\n            formatOption('--[no-]preserve-comments', 'remove / preserve comments in the output, defaults to false'),\n            formatOption('--include-all-sources', 'instrument all unused sources after running tests, defaults to false'),\n            formatOption('--[no-]include-pid', 'include PID in output coverage filename')\n        ].join('\\n\\n') + '\\n');\n    console.error('\\n');\n}\n\nfunction run(args, commandName, enableHooks, callback) {\n\n    var template = {\n            config: path,\n            root: path,\n            x: [ Array, String ],\n            report: [Array, String ],\n            dir: path,\n            verbose: Boolean,\n            yui: Boolean,\n            'default-excludes': Boolean,\n            print: String,\n            'self-test': Boolean,\n            'hook-run-in-context': Boolean,\n            'post-require-hook': String,\n            'preserve-comments': Boolean,\n            'include-all-sources': Boolean,\n            'preload-sources': Boolean,\n            i: [ Array, String ],\n            'include-pid': Boolean\n        },\n        opts = nopt(template, { v : '--verbose' }, args, 0),\n        overrides = {\n            verbose: opts.verbose,\n            instrumentation: {\n                root: opts.root,\n                'default-excludes': opts['default-excludes'],\n                excludes: opts.x,\n                'include-all-sources': opts['include-all-sources'],\n                'preload-sources': opts['preload-sources'],\n                'include-pid': opts['include-pid']\n            },\n            reporting: {\n                reports: opts.report,\n                print: opts.print,\n                dir: opts.dir\n            },\n            hooks: {\n                'hook-run-in-context': opts['hook-run-in-context'],\n                'post-require-hook': opts['post-require-hook'],\n                'handle-sigint': opts['handle-sigint']\n            }\n        },\n        config = configuration.loadFile(opts.config, overrides),\n        verbose = config.verbose,\n        cmdAndArgs = opts.argv.remain,\n        preserveComments = opts['preserve-comments'],\n        includePid = opts['include-pid'],\n        cmd,\n        cmdArgs,\n        reportingDir,\n        reporter = new Reporter(config),\n        runFn,\n        excludes;\n\n    if (cmdAndArgs.length === 0) {\n        return callback(inputError.create('Need a filename argument for the ' + commandName + ' command!'));\n    }\n\n    cmd = cmdAndArgs.shift();\n    cmdArgs = cmdAndArgs;\n\n    if (!existsSync(cmd)) {\n        try {\n            cmd = which.sync(cmd);\n        } catch (ex) {\n            return callback(inputError.create('Unable to resolve file [' + cmd + ']'));\n        }\n    } else {\n        cmd = path.resolve(cmd);\n    }\n\n    runFn = function () {\n        process.argv = [\"node\", cmd].concat(cmdArgs);\n        if (verbose) {\n            console.log('Running: ' + process.argv.join(' '));\n        }\n        process.env.running_under_istanbul=1;\n        Module.runMain(cmd, null, true);\n    };\n\n    excludes = config.instrumentation.excludes(true);\n\n    if (enableHooks) {\n        reportingDir = path.resolve(config.reporting.dir());\n        mkdirp.sync(reportingDir); //ensure we fail early if we cannot do this\n        reporter.dir = reportingDir;\n        reporter.addAll(config.reporting.reports());\n        if (config.reporting.print() !== 'none') {\n            switch (config.reporting.print()) {\n            case 'detail':\n                reporter.add('text');\n                break;\n            case 'both':\n                reporter.add('text');\n                reporter.add('text-summary');\n                break;\n            default:\n                reporter.add('text-summary');\n                break;\n            }\n        }\n\n        excludes.push(path.relative(process.cwd(), path.join(reportingDir, '**', '*')));\n        matcherFor({\n            root: config.instrumentation.root() || process.cwd(),\n            includes: opts.i || config.instrumentation.extensions().map(function (ext) {\n                return '**/*' + ext;\n            }),\n            excludes: excludes\n        },\n            function (err, matchFn) {\n                if (err) { return callback(err); }\n\n                var coverageVar = '$$cov_' + new Date().getTime() + '$$',\n                    instrumenter = new Instrumenter({ coverageVariable: coverageVar , preserveComments: preserveComments}),\n                    transformer = instrumenter.instrumentSync.bind(instrumenter),\n                    hookOpts = { verbose: verbose, extensions: config.instrumentation.extensions() },\n                    postRequireHook = config.hooks.postRequireHook(),\n                    postLoadHookFile;\n\n                if (postRequireHook) {\n                    postLoadHookFile = path.resolve(postRequireHook);\n                } else if (opts.yui) { //EXPERIMENTAL code: do not rely on this in anyway until the docs say it is allowed\n                    postLoadHookFile = path.resolve(__dirname, '../../util/yui-load-hook');\n                }\n\n                if (postRequireHook) {\n                    if (!existsSync(postLoadHookFile)) { //assume it is a module name and resolve it\n                        try {\n                            postLoadHookFile = resolve.sync(postRequireHook, { basedir: process.cwd() });\n                        } catch (ex) {\n                            if (verbose) { console.error('Unable to resolve [' + postRequireHook + '] as a node module'); }\n                            callback(ex);\n                            return;\n                        }\n                    }\n                }\n                if (postLoadHookFile) {\n                    if (verbose) { console.error('Use post-load-hook: ' + postLoadHookFile); }\n                    hookOpts.postLoadHook = require(postLoadHookFile)(matchFn, transformer, verbose);\n                }\n\n                if (opts['self-test']) {\n                    hook.unloadRequireCache(matchFn);\n                }\n                // runInThisContext is used by RequireJS [issue #23]\n                if (config.hooks.hookRunInContext()) {\n                    hook.hookRunInThisContext(matchFn, transformer, hookOpts);\n                }\n                hook.hookRequire(matchFn, transformer, hookOpts);\n\n                //initialize the global variable to stop mocha from complaining about leaks\n                global[coverageVar] = {};\n\n                // enable passing --handle-sigint to write reports on SIGINT.\n                // This allows a user to manually kill a process while\n                // still getting the istanbul report.\n                if (config.hooks.handleSigint()) {\n                    process.once('SIGINT', process.exit);\n                }\n\n                process.once('exit', function () {\n                    var pidExt = includePid ? ('-' + process.pid) : '',\n                        file = path.resolve(reportingDir, 'coverage' + pidExt + '.json'),\n                        collector,\n                        cov;\n                    if (typeof global[coverageVar] === 'undefined' || Object.keys(global[coverageVar]).length === 0) {\n                        console.error('No coverage information was collected, exit without writing coverage information');\n                        return;\n                    } else {\n                        cov = global[coverageVar];\n                    }\n                    //important: there is no event loop at this point\n                    //everything that happens in this exit handler MUST be synchronous\n                    if (config.instrumentation.includeAllSources()) {\n                        // Files that are not touched by code ran by the test runner is manually instrumented, to\n                        // illustrate the missing coverage.\n                        matchFn.files.forEach(function (file) {\n                            if (!cov[file]) {\n                                transformer(fs.readFileSync(file, 'utf-8'), file);\n\n                                // When instrumenting the code, istanbul will give each FunctionDeclaration a value of 1 in coverState.s,\n                                // presumably to compensate for function hoisting. We need to reset this, as the function was not hoisted,\n                                // as it was never loaded.\n                                Object.keys(instrumenter.coverState.s).forEach(function (key) {\n                                    instrumenter.coverState.s[key] = 0;\n                                });\n\n                                cov[file] = instrumenter.coverState;\n                            }\n                        });\n                    }\n                    mkdirp.sync(reportingDir); //yes, do this again since some test runners could clean the dir initially created\n                    if (config.reporting.print() !== 'none') {\n                        console.error('=============================================================================');\n                        console.error('Writing coverage object [' + file + ']');\n                    }\n                    fs.writeFileSync(file, JSON.stringify(cov), 'utf8');\n                    collector = new Collector();\n                    collector.add(cov);\n                    if (config.reporting.print() !== 'none') {\n                        console.error('Writing coverage reports at [' + reportingDir + ']');\n                        console.error('=============================================================================');\n                    }\n                    reporter.write(collector, true, callback);\n                });\n                runFn();\n            });\n    } else {\n        runFn();\n    }\n}\n\nmodule.exports = {\n    run: run,\n    usage: usage\n};\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/util/input-error.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nmodule.exports.create = function (message) {\n    var err = new Error(message);\n    err.inputError = true;\n    return err;\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/instrumenter.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/*global esprima, escodegen, window */\n(function (isNode) {\n    \"use strict\";\n    var SYNTAX,\n        nodeType,\n        ESP = isNode ? require('esprima') : esprima,\n        ESPGEN = isNode ? require('escodegen') : escodegen,  //TODO - package as dependency\n        crypto = isNode ? require('crypto') : null,\n        LEADER_WRAP = '(function () { ',\n        TRAILER_WRAP = '\\n}());',\n        COMMENT_RE = /^\\s*istanbul\\s+ignore\\s+(if|else|next)(?=\\W|$)/,\n        astgen,\n        preconditions,\n        cond,\n        isArray = Array.isArray;\n\n    /* istanbul ignore if: untestable */\n    if (!isArray) {\n        isArray = function (thing) { return thing &&  Object.prototype.toString.call(thing) === '[object Array]'; };\n    }\n\n    if (!isNode) {\n        preconditions = {\n            'Could not find esprima': ESP,\n            'Could not find escodegen': ESPGEN,\n            'JSON object not in scope': JSON,\n            'Array does not implement push': [].push,\n            'Array does not implement unshift': [].unshift\n        };\n        /* istanbul ignore next: untestable */\n        for (cond in preconditions) {\n            if (preconditions.hasOwnProperty(cond)) {\n                if (!preconditions[cond]) { throw new Error(cond); }\n            }\n        }\n    }\n\n    function generateTrackerVar(filename, omitSuffix) {\n        var hash, suffix;\n        if (crypto !== null) {\n            hash = crypto.createHash('md5');\n            hash.update(filename);\n            suffix = hash.digest('base64');\n            //trim trailing equal signs, turn identifier unsafe chars to safe ones + => _ and / => $\n            suffix = suffix.replace(new RegExp('=', 'g'), '')\n                .replace(new RegExp('\\\\+', 'g'), '_')\n                .replace(new RegExp('/', 'g'), '$');\n        } else {\n            window.__cov_seq = window.__cov_seq || 0;\n            window.__cov_seq += 1;\n            suffix = window.__cov_seq;\n        }\n        return '__cov_' + (omitSuffix ? '' : suffix);\n    }\n\n    function pushAll(ary, thing) {\n        if (!isArray(thing)) {\n            thing = [ thing ];\n        }\n        Array.prototype.push.apply(ary, thing);\n    }\n\n    SYNTAX = {\n        // keep in sync with estraverse's VisitorKeys\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'body'],\n        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MetaProperty: ['meta', 'property'],\n        MemberExpression: ['object', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        RestElement: [ 'argument' ],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        Super: [],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handler', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    for (nodeType in SYNTAX) {\n        /* istanbul ignore else: has own property */\n        if (SYNTAX.hasOwnProperty(nodeType)) {\n            SYNTAX[nodeType] = { name: nodeType, children: SYNTAX[nodeType] };\n        }\n    }\n\n    astgen = {\n        variable: function (name) { return { type: SYNTAX.Identifier.name, name: name }; },\n        stringLiteral: function (str) { return { type: SYNTAX.Literal.name, value: String(str) }; },\n        numericLiteral: function (num) { return { type: SYNTAX.Literal.name, value: Number(num) }; },\n        statement: function (contents) { return { type: SYNTAX.ExpressionStatement.name, expression: contents }; },\n        dot: function (obj, field) { return { type: SYNTAX.MemberExpression.name, computed: false, object: obj, property: field }; },\n        subscript: function (obj, sub) { return { type: SYNTAX.MemberExpression.name, computed: true, object: obj, property: sub }; },\n        postIncrement: function (obj) { return { type: SYNTAX.UpdateExpression.name, operator: '++', prefix: false, argument: obj }; },\n        sequence: function (one, two) { return { type: SYNTAX.SequenceExpression.name, expressions: [one, two] }; },\n        returnStatement: function (expr) { return { type: SYNTAX.ReturnStatement.name, argument: expr }; }\n    };\n\n    function Walker(walkMap, preprocessor, scope, debug) {\n        this.walkMap = walkMap;\n        this.preprocessor = preprocessor;\n        this.scope = scope;\n        this.debug = debug;\n        if (this.debug) {\n            this.level = 0;\n            this.seq = true;\n        }\n    }\n\n    function defaultWalker(node, walker) {\n\n        var type = node.type,\n            preprocessor,\n            postprocessor,\n            children = SYNTAX[type],\n            // don't run generated nodes thru custom walks otherwise we will attempt to instrument the instrumentation code :)\n            applyCustomWalker = !!node.loc || node.type === SYNTAX.Program.name,\n            walkerFn = applyCustomWalker ? walker.walkMap[type] : null,\n            i,\n            j,\n            walkFnIndex,\n            childType,\n            childNode,\n            ret,\n            childArray,\n            childElement,\n            pathElement,\n            assignNode,\n            isLast;\n\n        if (!SYNTAX[type]) {\n            console.error(node);\n            console.error('Unsupported node type:' + type);\n            return;\n        }\n        children = SYNTAX[type].children;\n        /* istanbul ignore if: guard */\n        if (node.walking) { throw new Error('Infinite regress: Custom walkers may NOT call walker.apply(node)'); }\n        node.walking = true;\n\n        ret = walker.apply(node, walker.preprocessor);\n\n        preprocessor = ret.preprocessor;\n        if (preprocessor) {\n            delete ret.preprocessor;\n            ret = walker.apply(node, preprocessor);\n        }\n\n        if (isArray(walkerFn)) {\n            for (walkFnIndex = 0; walkFnIndex < walkerFn.length; walkFnIndex += 1) {\n                isLast = walkFnIndex === walkerFn.length - 1;\n                ret = walker.apply(ret, walkerFn[walkFnIndex]);\n                /*istanbul ignore next: paranoid check */\n                if (ret.type !== type && !isLast) {\n                    throw new Error('Only the last walker is allowed to change the node type: [type was: ' + type + ' ]');\n                }\n            }\n        } else {\n            if (walkerFn) {\n                ret = walker.apply(node, walkerFn);\n            }\n        }\n\n        if (node.skipSelf) {\n            return;\n        }\n\n        for (i = 0; i < children.length; i += 1) {\n            childType = children[i];\n            childNode = node[childType];\n            if (childNode && !childNode.skipWalk) {\n                pathElement = { node: node, property: childType };\n                if (isArray(childNode)) {\n                    childArray = [];\n                    for (j = 0; j < childNode.length; j += 1) {\n                        childElement = childNode[j];\n                        pathElement.index = j;\n                        if (childElement) {\n                          assignNode = walker.apply(childElement, null, pathElement);\n                          if (isArray(assignNode.prepend)) {\n                              pushAll(childArray, assignNode.prepend);\n                              delete assignNode.prepend;\n                          }\n                        } else {\n                            assignNode = undefined;\n                        }\n                        pushAll(childArray, assignNode);\n                    }\n                    node[childType] = childArray;\n                } else {\n                    assignNode = walker.apply(childNode, null, pathElement);\n                    /*istanbul ignore if: paranoid check */\n                    if (isArray(assignNode.prepend)) {\n                        throw new Error('Internal error: attempt to prepend statements in disallowed (non-array) context');\n                        /* if this should be allowed, this is how to solve it\n                        tmpNode = { type: 'BlockStatement', body: [] };\n                        pushAll(tmpNode.body, assignNode.prepend);\n                        pushAll(tmpNode.body, assignNode);\n                        node[childType] = tmpNode;\n                        delete assignNode.prepend;\n                        */\n                    } else {\n                        node[childType] = assignNode;\n                    }\n                }\n            }\n        }\n\n        postprocessor = ret.postprocessor;\n        if (postprocessor) {\n            delete ret.postprocessor;\n            ret = walker.apply(ret, postprocessor);\n        }\n\n        delete node.walking;\n\n        return ret;\n    }\n\n    Walker.prototype = {\n        startWalk: function (node) {\n            this.path = [];\n            this.apply(node);\n        },\n\n        apply: function (node, walkFn, pathElement) {\n            var ret, i, seq, prefix;\n\n            walkFn = walkFn || defaultWalker;\n            if (this.debug) {\n                this.seq += 1;\n                this.level += 1;\n                seq = this.seq;\n                prefix = '';\n                for (i = 0; i < this.level; i += 1) { prefix += '    '; }\n                console.log(prefix + 'Enter (' + seq + '):' + node.type);\n            }\n            if (pathElement) { this.path.push(pathElement); }\n            ret = walkFn.call(this.scope, node, this);\n            if (pathElement) { this.path.pop(); }\n            if (this.debug) {\n                this.level -= 1;\n                console.log(prefix + 'Return (' + seq + '):' + node.type);\n            }\n            return ret || node;\n        },\n\n        startLineForNode: function (node) {\n            return node && node.loc && node.loc.start ? node.loc.start.line : /* istanbul ignore next: guard */ null;\n        },\n\n        ancestor: function (n) {\n            return this.path.length > n - 1 ? this.path[this.path.length - n] : /* istanbul ignore next: guard */ null;\n        },\n\n        parent: function () {\n            return this.ancestor(1);\n        },\n\n        isLabeled: function () {\n            var el = this.parent();\n            return el && el.node.type === SYNTAX.LabeledStatement.name;\n        }\n    };\n\n    /**\n     * mechanism to instrument code for coverage. It uses the `esprima` and\n     * `escodegen` libraries for JS parsing and code generation respectively.\n     *\n     * Works on `node` as well as the browser.\n     *\n     * Usage on nodejs\n     * ---------------\n     *\n     *      var instrumenter = new require('istanbul').Instrumenter(),\n     *          changed = instrumenter.instrumentSync('function meaningOfLife() { return 42; }', 'filename.js');\n     *\n     * Usage in a browser\n     * ------------------\n     *\n     * Load `esprima.js`, `escodegen.js` and `instrumenter.js` (this file) using `script` tags or other means.\n     *\n     * Create an instrumenter object as:\n     *\n     *      var instrumenter = new Instrumenter(),\n     *          changed = instrumenter.instrumentSync('function meaningOfLife() { return 42; }', 'filename.js');\n     *\n     * Aside from demonstration purposes, it is unclear why you would want to instrument code in a browser.\n     *\n     * @class Instrumenter\n     * @constructor\n     * @param {Object} options Optional. Configuration options.\n     * @param {String} [options.coverageVariable] the global variable name to use for\n     *      tracking coverage. Defaults to `__coverage__`\n     * @param {Boolean} [options.embedSource] whether to embed the source code of every\n     *      file as an array in the file coverage object for that file. Defaults to `false`\n     * @param {Boolean} [options.preserveComments] whether comments should be preserved in the output. Defaults to `false`\n     * @param {Boolean} [options.noCompact] emit readable code when set. Defaults to `false`\n     * @param {Boolean} [options.esModules] whether the code to instrument contains uses es\n     *      imports or exports.\n     * @param {Boolean} [options.noAutoWrap] do not automatically wrap the source in\n     *      an anonymous function before covering it. By default, code is wrapped in\n     *      an anonymous function before it is parsed. This is done because\n     *      some nodejs libraries have `return` statements outside of\n     *      a function which is technically invalid Javascript and causes the parser to fail.\n     *      This construct, however, works correctly in node since module loading\n     *      is done in the context of an anonymous function.\n     *\n     * Note that the semantics of the code *returned* by the instrumenter does not change in any way.\n     * The function wrapper is \"unwrapped\" before the instrumented code is generated.\n     * @param {Object} [options.codeGenerationOptions] an object that is directly passed to the `escodegen`\n     *      library as configuration for code generation. The `noCompact` setting is not honored when this\n     *      option is specified\n     * @param {Boolean} [options.debug] assist in debugging. Currently, the only effect of\n     *      setting this option is a pretty-print of the coverage variable. Defaults to `false`\n     * @param {Boolean} [options.walkDebug] assist in debugging of the AST walker used by this class.\n     *\n     */\n    function Instrumenter(options) {\n        this.opts = options || {\n            debug: false,\n            walkDebug: false,\n            coverageVariable: '__coverage__',\n            codeGenerationOptions: undefined,\n            noAutoWrap: false,\n            noCompact: false,\n            embedSource: false,\n            preserveComments: false,\n            esModules: false\n        };\n\n        if (this.opts.esModules && !this.opts.noAutoWrap) {\n            this.opts.noAutoWrap = true;\n            if (this.opts.debug) {\n                console.log('Setting noAutoWrap to true as required by esModules');\n            }\n        }\n\n        this.walker = new Walker({\n            ArrowFunctionExpression: [ this.arrowBlockConverter ],\n            ExpressionStatement: this.coverStatement,\n            ExportNamedDeclaration: this.coverExport,\n            BreakStatement: this.coverStatement,\n            ContinueStatement: this.coverStatement,\n            DebuggerStatement: this.coverStatement,\n            ReturnStatement: this.coverStatement,\n            ThrowStatement: this.coverStatement,\n            TryStatement: [ this.paranoidHandlerCheck, this.coverStatement],\n            VariableDeclaration: this.coverStatement,\n            IfStatement: [ this.ifBlockConverter, this.coverStatement, this.ifBranchInjector ],\n            ForStatement: [ this.skipInit, this.loopBlockConverter, this.coverStatement ],\n            ForInStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],\n            ForOfStatement: [ this.skipLeft, this.loopBlockConverter, this.coverStatement ],\n            WhileStatement: [ this.loopBlockConverter, this.coverStatement ],\n            DoWhileStatement: [ this.loopBlockConverter, this.coverStatement ],\n            SwitchStatement: [ this.coverStatement, this.switchBranchInjector ],\n            SwitchCase: [ this.switchCaseInjector ],\n            WithStatement: [ this.withBlockConverter, this.coverStatement ],\n            FunctionDeclaration: [ this.coverFunction, this.coverStatement ],\n            FunctionExpression: this.coverFunction,\n            LabeledStatement: this.coverStatement,\n            ConditionalExpression: this.conditionalBranchInjector,\n            LogicalExpression: this.logicalExpressionBranchInjector,\n            ObjectExpression: this.maybeAddType,\n            MetaProperty: this.coverMetaProperty,\n        }, this.extractCurrentHint, this, this.opts.walkDebug);\n\n        //unit testing purposes only\n        if (this.opts.backdoor && this.opts.backdoor.omitTrackerSuffix) {\n            this.omitTrackerSuffix = true;\n        }\n    }\n\n    Instrumenter.prototype = {\n        /**\n         * synchronous instrumentation method. Throws when illegal code is passed to it\n         * @method instrumentSync\n         * @param {String} code the code to be instrumented as a String\n         * @param {String} filename Optional. The name of the file from which\n         *  the code was read. A temporary filename is generated when not specified.\n         *  Not specifying a filename is only useful for unit tests and demonstrations\n         *  of this library.\n         */\n        instrumentSync: function (code, filename) {\n            var program;\n\n            //protect from users accidentally passing in a Buffer object instead\n            if (typeof code !== 'string') { throw new Error('Code must be string'); }\n            if (code.charAt(0) === '#') { //shebang, 'comment' it out, won't affect syntax tree locations for things we care about\n                code = '//' + code;\n            }\n            if (!this.opts.noAutoWrap) {\n                code = LEADER_WRAP + code + TRAILER_WRAP;\n            }\n            try {\n                program = ESP.parse(code, {\n                    loc: true,\n                    range: true,\n                    tokens: this.opts.preserveComments,\n                    comment: true,\n                    sourceType: this.opts.esModules ? 'module' : 'script'\n                });\n            } catch (e) {\n                console.log('Failed to parse file: ' + filename);\n                throw e;\n            }\n            if (this.opts.preserveComments) {\n                program = ESPGEN.attachComments(program, program.comments, program.tokens);\n            }\n            if (!this.opts.noAutoWrap) {\n                program = {\n                    type: SYNTAX.Program.name,\n                    body: program.body[0].expression.callee.body.body,\n                    comments: program.comments\n                };\n            }\n            return this.instrumentASTSync(program, filename, code);\n        },\n        filterHints: function (comments) {\n            var ret = [],\n                i,\n                comment,\n                groups;\n            if (!(comments && isArray(comments))) {\n                return ret;\n            }\n            for (i = 0; i < comments.length; i += 1) {\n                comment = comments[i];\n                /* istanbul ignore else: paranoid check */\n                if (comment && comment.value && comment.range && isArray(comment.range)) {\n                    groups = String(comment.value).match(COMMENT_RE);\n                    if (groups) {\n                        ret.push({ type: groups[1], start: comment.range[0], end: comment.range[1] });\n                    }\n                }\n            }\n            return ret;\n        },\n        extractCurrentHint: function (node) {\n            if (!node.range) { return; }\n            var i = this.currentState.lastHintPosition + 1,\n                hints = this.currentState.hints,\n                nodeStart = node.range[0],\n                hint;\n            this.currentState.currentHint = null;\n            while (i < hints.length) {\n                hint = hints[i];\n                if (hint.end < nodeStart) {\n                    this.currentState.currentHint = hint;\n                    this.currentState.lastHintPosition = i;\n                    i += 1;\n                } else {\n                    break;\n                }\n            }\n        },\n        /**\n         * synchronous instrumentation method that instruments an AST instead.\n         * @method instrumentASTSync\n         * @param {String} program the AST to be instrumented\n         * @param {String} filename Optional. The name of the file from which\n         *  the code was read. A temporary filename is generated when not specified.\n         *  Not specifying a filename is only useful for unit tests and demonstrations\n         *  of this library.\n         *  @param {String} originalCode the original code corresponding to the AST,\n         *  used for embedding the source into the coverage object\n         */\n        instrumentASTSync: function (program, filename, originalCode) {\n            var usingStrict = false,\n                codegenOptions,\n                generated,\n                preamble,\n                lineCount,\n                i;\n            filename = filename || String(new Date().getTime()) + '.js';\n            this.sourceMap = null;\n            this.coverState = {\n                path: filename,\n                s: {},\n                b: {},\n                f: {},\n                fnMap: {},\n                statementMap: {},\n                branchMap: {}\n            };\n            this.currentState = {\n                trackerVar: generateTrackerVar(filename, this.omitTrackerSuffix),\n                func: 0,\n                branch: 0,\n                variable: 0,\n                statement: 0,\n                hints: this.filterHints(program.comments),\n                currentHint: null,\n                lastHintPosition: -1,\n                ignoring: 0\n            };\n            if (program.body && program.body.length > 0 && this.isUseStrictExpression(program.body[0])) {\n                //nuke it\n                program.body.shift();\n                //and add it back at code generation time\n                usingStrict = true;\n            }\n            this.walker.startWalk(program);\n            codegenOptions = this.opts.codeGenerationOptions || { format: { compact: !this.opts.noCompact }};\n            codegenOptions.comment = this.opts.preserveComments;\n            //console.log(JSON.stringify(program, undefined, 2));\n\n            generated = ESPGEN.generate(program, codegenOptions);\n            preamble = this.getPreamble(originalCode || '', usingStrict);\n\n            if (generated.map && generated.code) {\n                lineCount = preamble.split(/\\r\\n|\\r|\\n/).length;\n                // offset all the generated line numbers by the number of lines in the preamble\n                for (i = 0; i < generated.map._mappings._array.length; i += 1) {\n                    generated.map._mappings._array[i].generatedLine += lineCount;\n                }\n                this.sourceMap = generated.map;\n                generated = generated.code;\n            }\n\n            return preamble + '\\n' + generated + '\\n';\n        },\n        /**\n         * Callback based instrumentation. Note that this still executes synchronously in the same process tick\n         * and calls back immediately. It only provides the options for callback style error handling as\n         * opposed to a `try-catch` style and nothing more. Implemented as a wrapper over `instrumentSync`\n         *\n         * @method instrument\n         * @param {String} code the code to be instrumented as a String\n         * @param {String} filename Optional. The name of the file from which\n         *  the code was read. A temporary filename is generated when not specified.\n         *  Not specifying a filename is only useful for unit tests and demonstrations\n         *  of this library.\n         * @param {Function(err, instrumentedCode)} callback - the callback function\n         */\n        instrument: function (code, filename, callback) {\n\n            if (!callback && typeof filename === 'function') {\n                callback = filename;\n                filename = null;\n            }\n            try {\n                callback(null, this.instrumentSync(code, filename));\n            } catch (ex) {\n                callback(ex);\n            }\n        },\n        /**\n         * returns the file coverage object for the code that was instrumented\n         * just before calling this method. Note that this represents a\n         * \"zero-coverage\" object which is not even representative of the code\n         * being loaded in node or a browser (which would increase the statement\n         * counts for mainline code).\n         * @method lastFileCoverage\n         * @return {Object} a \"zero-coverage\" file coverage object for the code last instrumented\n         * by this instrumenter\n         */\n        lastFileCoverage: function () {\n            return this.coverState;\n        },\n        /**\n         * returns the source map object for the code that was instrumented\n         * just before calling this method.\n         * @method lastSourceMap\n         * @return {Object} a source map object for the code last instrumented\n         * by this instrumenter\n         */\n        lastSourceMap: function () {\n            return this.sourceMap;\n        },\n        fixColumnPositions: function (coverState) {\n            var offset = LEADER_WRAP.length,\n                fixer = function (loc) {\n                    if (loc.start.line === 1) {\n                        loc.start.column -= offset;\n                    }\n                    if (loc.end.line === 1) {\n                        loc.end.column -= offset;\n                    }\n                },\n                k,\n                obj,\n                i,\n                locations;\n\n            obj = coverState.statementMap;\n            for (k in obj) {\n                /* istanbul ignore else: has own property */\n                if (obj.hasOwnProperty(k)) { fixer(obj[k]); }\n            }\n            obj = coverState.fnMap;\n            for (k in obj) {\n                /* istanbul ignore else: has own property */\n                if (obj.hasOwnProperty(k)) { fixer(obj[k].loc); }\n            }\n            obj = coverState.branchMap;\n            for (k in obj) {\n                /* istanbul ignore else: has own property */\n                if (obj.hasOwnProperty(k)) {\n                    locations = obj[k].locations;\n                    for (i = 0; i < locations.length; i += 1) {\n                        fixer(locations[i]);\n                    }\n                }\n            }\n        },\n\n        getPreamble: function (sourceCode, emitUseStrict) {\n            var varName = this.opts.coverageVariable || '__coverage__',\n                file = this.coverState.path.replace(/\\\\/g, '\\\\\\\\'),\n                tracker = this.currentState.trackerVar,\n                coverState,\n                strictLine = emitUseStrict ? '\"use strict\";' : '',\n                // return replacements using the function to ensure that the replacement is\n                // treated like a dumb string and not as a string with RE replacement patterns\n                replacer = function (s) {\n                    return function () { return s; };\n                },\n                code;\n            if (!this.opts.noAutoWrap) {\n                this.fixColumnPositions(this.coverState);\n            }\n            if (this.opts.embedSource) {\n                this.coverState.code = sourceCode.split(/(?:\\r?\\n)|\\r/);\n            }\n            coverState = this.opts.debug ? JSON.stringify(this.coverState, undefined, 4) : JSON.stringify(this.coverState);\n            code = [\n                \"%STRICT%\",\n                \"var %VAR% = (Function('return this'))();\",\n                \"if (!%VAR%.%GLOBAL%) { %VAR%.%GLOBAL% = {}; }\",\n                \"%VAR% = %VAR%.%GLOBAL%;\",\n                \"if (!(%VAR%['%FILE%'])) {\",\n                \"   %VAR%['%FILE%'] = %OBJECT%;\",\n                \"}\",\n                \"%VAR% = %VAR%['%FILE%'];\"\n            ].join(\"\\n\")\n                .replace(/%STRICT%/g, replacer(strictLine))\n                .replace(/%VAR%/g, replacer(tracker))\n                .replace(/%GLOBAL%/g, replacer(varName))\n                .replace(/%FILE%/g, replacer(file))\n                .replace(/%OBJECT%/g, replacer(coverState));\n            return code;\n        },\n\n        startIgnore: function () {\n            this.currentState.ignoring += 1;\n        },\n\n        endIgnore: function () {\n            this.currentState.ignoring -= 1;\n        },\n\n        convertToBlock: function (node) {\n            if (!node) {\n                return { type: 'BlockStatement', body: [] };\n            } else if (node.type === 'BlockStatement') {\n                return node;\n            } else {\n                return { type: 'BlockStatement', body: [ node ] };\n            }\n        },\n\n        arrowBlockConverter: function (node) {\n            var retStatement;\n            if (node.expression) { // turn expression nodes into a block with a return statement\n                retStatement = astgen.returnStatement(node.body);\n                // ensure the generated return statement is covered\n                retStatement.loc = node.body.loc;\n                node.body = this.convertToBlock(retStatement);\n                node.expression = false;\n            }\n        },\n\n        paranoidHandlerCheck: function (node) {\n            // if someone is using an older esprima on the browser\n            // convert handlers array to single handler attribute\n            // containing its first element\n            /* istanbul ignore next */\n            if (!node.handler && node.handlers) {\n                node.handler = node.handlers[0];\n            }\n        },\n\n        ifBlockConverter: function (node) {\n            node.consequent = this.convertToBlock(node.consequent);\n            node.alternate = this.convertToBlock(node.alternate);\n        },\n\n        loopBlockConverter: function (node) {\n            node.body = this.convertToBlock(node.body);\n        },\n\n        withBlockConverter: function (node) {\n            node.body = this.convertToBlock(node.body);\n        },\n\n        statementName: function (location, initValue) {\n            var sName,\n                ignoring = !!this.currentState.ignoring;\n\n            location.skip = ignoring || undefined;\n            initValue = initValue || 0;\n            this.currentState.statement += 1;\n            sName = this.currentState.statement;\n            this.coverState.statementMap[sName] = location;\n            this.coverState.s[sName] = initValue;\n            return sName;\n        },\n\n        skipInit: function (node /*, walker */) {\n            if (node.init) {\n                node.init.skipWalk = true;\n            }\n        },\n\n        skipLeft: function (node /*, walker */) {\n            node.left.skipWalk = true;\n        },\n\n        isUseStrictExpression: function (node) {\n            return node && node.type === SYNTAX.ExpressionStatement.name &&\n                node.expression  && node.expression.type === SYNTAX.Literal.name &&\n                node.expression.value === 'use strict';\n        },\n\n        maybeSkipNode: function (node, type) {\n            var alreadyIgnoring = !!this.currentState.ignoring,\n                hint = this.currentState.currentHint,\n                ignoreThis = !alreadyIgnoring && hint && hint.type === type;\n\n            if (ignoreThis) {\n                this.startIgnore();\n                node.postprocessor = this.endIgnore;\n                return true;\n            }\n            return false;\n        },\n\n        coverMetaProperty: function(node /* , walker */) {\n           node.skipSelf = true;\n        },\n\n        coverStatement: function (node, walker) {\n            var sName,\n                incrStatementCount,\n                parent,\n                grandParent;\n\n            this.maybeSkipNode(node, 'next');\n\n            if (this.isUseStrictExpression(node)) {\n                grandParent = walker.ancestor(2);\n                /* istanbul ignore else: difficult to test */\n                if (grandParent) {\n                    if ((grandParent.node.type === SYNTAX.FunctionExpression.name ||\n                        grandParent.node.type === SYNTAX.FunctionDeclaration.name)  &&\n                        walker.parent().node.body[0] === node) {\n                        return;\n                    }\n                }\n            }\n\n            if (node.type === SYNTAX.FunctionDeclaration.name) {\n                // Called for the side-effect of setting the function's statement count to 1.\n                this.statementName(node.loc, 1);\n            } else {\n                // We let `coverExport` handle ExportNamedDeclarations.\n                parent = walker.parent();\n                if (parent && parent.node.type === SYNTAX.ExportNamedDeclaration.name) {\n                    return;\n                }\n\n                sName = this.statementName(node.loc);\n\n                incrStatementCount = astgen.statement(\n                    astgen.postIncrement(\n                        astgen.subscript(\n                            astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable('s')),\n                            astgen.stringLiteral(sName)\n                        )\n                    )\n                );\n\n                this.splice(incrStatementCount, node, walker);\n            }\n        },\n\n        coverExport: function (node, walker) {\n            var sName, incrStatementCount;\n\n            if ( !node.declaration || !node.declaration.declarations ) { return; }\n\n            this.maybeSkipNode(node, 'next');\n\n            sName = this.statementName(node.declaration.loc);\n            incrStatementCount = astgen.statement(\n                astgen.postIncrement(\n                    astgen.subscript(\n                        astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable('s')),\n                        astgen.stringLiteral(sName)\n                    )\n                )\n            );\n\n            this.splice(incrStatementCount, node, walker);\n        },\n\n        splice: function (statements, node, walker) {\n            var targetNode = walker.isLabeled() ? walker.parent().node : node;\n            targetNode.prepend = targetNode.prepend || [];\n            pushAll(targetNode.prepend, statements);\n        },\n\n        functionName: function (node, line, location) {\n            this.currentState.func += 1;\n            var id = this.currentState.func,\n                ignoring = !!this.currentState.ignoring,\n                name = node.id ? node.id.name : '(anonymous_' + id + ')',\n                clone = function (attr) {\n                    var obj = location[attr] || /* istanbul ignore next */ {};\n                    return { line: obj.line, column: obj.column };\n                };\n            this.coverState.fnMap[id] = {\n                name: name, line: line,\n                loc: {\n                    start: clone('start'),\n                    end: clone('end')\n                },\n                skip: ignoring || undefined\n            };\n            this.coverState.f[id] = 0;\n            return id;\n        },\n\n        coverFunction: function (node, walker) {\n            var id,\n                body = node.body,\n                blockBody = body.body,\n                popped;\n\n            this.maybeSkipNode(node, 'next');\n\n            id = this.functionName(node, walker.startLineForNode(node), {\n                start: node.loc.start,\n                end: { line: node.body.loc.start.line, column: node.body.loc.start.column }\n            });\n\n            if (blockBody.length > 0 && this.isUseStrictExpression(blockBody[0])) {\n                popped = blockBody.shift();\n            }\n            blockBody.unshift(\n                astgen.statement(\n                    astgen.postIncrement(\n                        astgen.subscript(\n                            astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable('f')),\n                            astgen.stringLiteral(id)\n                        )\n                    )\n                )\n            );\n            if (popped) {\n                blockBody.unshift(popped);\n            }\n        },\n\n        branchName: function (type, startLine, pathLocations) {\n            var bName,\n                paths = [],\n                locations = [],\n                i,\n                ignoring = !!this.currentState.ignoring;\n            this.currentState.branch += 1;\n            bName = this.currentState.branch;\n            for (i = 0; i < pathLocations.length; i += 1) {\n                pathLocations[i].skip = pathLocations[i].skip || ignoring || undefined;\n                locations.push(pathLocations[i]);\n                paths.push(0);\n            }\n            this.coverState.b[bName] = paths;\n            this.coverState.branchMap[bName] = { line: startLine, type: type, locations: locations };\n            return bName;\n        },\n\n        branchIncrementExprAst: function (varName, branchIndex, down) {\n            var ret = astgen.postIncrement(\n                astgen.subscript(\n                    astgen.subscript(\n                        astgen.dot(astgen.variable(this.currentState.trackerVar), astgen.variable('b')),\n                        astgen.stringLiteral(varName)\n                    ),\n                    astgen.numericLiteral(branchIndex)\n                ),\n                down\n            );\n            return ret;\n        },\n\n        locationsForNodes: function (nodes) {\n            var ret = [],\n                i;\n            for (i = 0; i < nodes.length; i += 1) {\n                ret.push(nodes[i].loc);\n            }\n            return ret;\n        },\n\n        ifBranchInjector: function (node, walker) {\n            var alreadyIgnoring = !!this.currentState.ignoring,\n                hint = this.currentState.currentHint,\n                ignoreThen = !alreadyIgnoring && hint && hint.type === 'if',\n                ignoreElse = !alreadyIgnoring && hint && hint.type === 'else',\n                line = node.loc.start.line,\n                col = node.loc.start.column,\n                makeLoc = function () { return  { line: line, column: col }; },\n                bName = this.branchName('if', walker.startLineForNode(node), [\n                    { start: makeLoc(), end: makeLoc(), skip: ignoreThen || undefined },\n                    { start: makeLoc(), end: makeLoc(), skip: ignoreElse || undefined }\n                ]),\n                thenBody = node.consequent.body,\n                elseBody = node.alternate.body,\n                child;\n            thenBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 0)));\n            elseBody.unshift(astgen.statement(this.branchIncrementExprAst(bName, 1)));\n            if (ignoreThen) { child = node.consequent; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }\n            if (ignoreElse) { child = node.alternate; child.preprocessor = this.startIgnore; child.postprocessor = this.endIgnore; }\n        },\n\n        branchLocationFor: function (name, index) {\n            return this.coverState.branchMap[name].locations[index];\n        },\n\n        switchBranchInjector: function (node, walker) {\n            var cases = node.cases,\n                bName,\n                i;\n\n            if (!(cases && cases.length > 0)) {\n                return;\n            }\n            bName = this.branchName('switch', walker.startLineForNode(node), this.locationsForNodes(cases));\n            for (i = 0; i < cases.length; i += 1) {\n                cases[i].branchLocation = this.branchLocationFor(bName, i);\n                cases[i].consequent.unshift(astgen.statement(this.branchIncrementExprAst(bName, i)));\n            }\n        },\n\n        switchCaseInjector: function (node) {\n            var location = node.branchLocation;\n            delete node.branchLocation;\n            if (this.maybeSkipNode(node, 'next')) {\n                location.skip = true;\n            }\n        },\n\n        conditionalBranchInjector: function (node, walker) {\n            var bName = this.branchName('cond-expr', walker.startLineForNode(node), this.locationsForNodes([ node.consequent, node.alternate ])),\n                ast1 = this.branchIncrementExprAst(bName, 0),\n                ast2 = this.branchIncrementExprAst(bName, 1);\n\n            node.consequent.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 0));\n            node.alternate.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, 1));\n            node.consequent = astgen.sequence(ast1, node.consequent);\n            node.alternate = astgen.sequence(ast2, node.alternate);\n        },\n\n        maybeAddSkip: function (branchLocation) {\n            return function (node) {\n                var alreadyIgnoring = !!this.currentState.ignoring,\n                    hint = this.currentState.currentHint,\n                    ignoreThis = !alreadyIgnoring && hint && hint.type === 'next';\n                if (ignoreThis) {\n                    this.startIgnore();\n                    node.postprocessor = this.endIgnore;\n                }\n                if (ignoreThis || alreadyIgnoring) {\n                    branchLocation.skip = true;\n                }\n            };\n        },\n\n        logicalExpressionBranchInjector: function (node, walker) {\n            var parent = walker.parent(),\n                leaves = [],\n                bName,\n                tuple,\n                i;\n\n            this.maybeSkipNode(node, 'next');\n\n            if (parent && parent.node.type === SYNTAX.LogicalExpression.name) {\n                //already covered\n                return;\n            }\n\n            this.findLeaves(node, leaves);\n            bName = this.branchName('binary-expr',\n                walker.startLineForNode(node),\n                this.locationsForNodes(leaves.map(function (item) { return item.node; }))\n            );\n            for (i = 0; i < leaves.length; i += 1) {\n                tuple = leaves[i];\n                tuple.parent[tuple.property] = astgen.sequence(this.branchIncrementExprAst(bName, i), tuple.node);\n                tuple.node.preprocessor = this.maybeAddSkip(this.branchLocationFor(bName, i));\n            }\n        },\n\n        findLeaves: function (node, accumulator, parent, property) {\n            if (node.type === SYNTAX.LogicalExpression.name) {\n                this.findLeaves(node.left, accumulator, node, 'left');\n                this.findLeaves(node.right, accumulator, node, 'right');\n            } else {\n                accumulator.push({ node: node, parent: parent, property: property });\n            }\n        },\n        maybeAddType: function (node /*, walker */) {\n            var props = node.properties,\n                i,\n                child;\n            for (i = 0; i < props.length; i += 1) {\n                child = props[i];\n                if (!child.type) {\n                    child.type = SYNTAX.Property.name;\n                }\n            }\n        },\n    };\n\n    if (isNode) {\n        module.exports = Instrumenter;\n    } else {\n        window.Instrumenter = Instrumenter;\n    }\n\n}(typeof module !== 'undefined' && typeof module.exports !== 'undefined' && typeof exports !== 'undefined'));\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/hook.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/**\n * provides a mechanism to transform code in the scope of `require` or `vm.createScript`.\n * This mechanism is general and relies on a user-supplied `matcher` function that determines when transformations should be\n * performed and a user-supplied `transformer` function that performs the actual transform.\n * Instrumenting code for coverage is one specific example of useful hooking.\n *\n * Note that both the `matcher` and `transformer` must execute synchronously.\n *\n * For the common case of matching filesystem paths based on inclusion/ exclusion patterns, use the `matcherFor`\n * function in the istanbul API to get a matcher.\n *\n * It is up to the transformer to perform processing with side-effects, such as caching, storing the original\n * source code to disk in case of dynamically generated scripts etc. The `Store` class can help you with this.\n *\n * Usage\n * -----\n *\n *      var hook = require('istanbul').hook,\n *          myMatcher = function (file) { return file.match(/foo/); },\n *          myTransformer = function (code, file) { return 'console.log(\"' + file + '\");' + code; };\n *\n *      hook.hookRequire(myMatcher, myTransformer);\n *\n *      var foo = require('foo'); //will now print foo's module path to console\n *\n * @class Hook\n * @module main\n */\nvar path = require('path'),\n    fs = require('fs'),\n    Module = require('module'),\n    vm = require('vm'),\n    originalLoaders = {},\n    originalCreateScript = vm.createScript,\n    originalRunInThisContext = vm.runInThisContext;\n\nfunction transformFn(matcher, transformer, verbose) {\n\n    return function (code, filename) {\n        var shouldHook = typeof filename === 'string' && matcher(path.resolve(filename)),\n            transformed,\n            changed = false;\n\n        if (shouldHook) {\n            if (verbose) {\n                console.error('Module load hook: transform [' + filename + ']');\n            }\n            try {\n                transformed = transformer(code, filename);\n                changed = true;\n            } catch (ex) {\n                console.error('Transformation error; return original code');\n                console.error(ex);\n                transformed = code;\n            }\n        } else {\n            transformed = code;\n        }\n        return { code: transformed, changed: changed };\n    };\n}\n\nfunction unloadRequireCache(matcher) {\n    if (matcher && typeof require !== 'undefined' && require && require.cache) {\n        Object.keys(require.cache).forEach(function (filename) {\n            if (matcher(filename)) {\n                delete require.cache[filename];\n            }\n        });\n    }\n}\n/**\n * hooks `require` to return transformed code to the node module loader.\n * Exceptions in the transform result in the original code being used instead.\n * @method hookRequire\n * @static\n * @param matcher {Function(filePath)} a function that is called with the absolute path to the file being\n *  `require`-d. Should return a truthy value when transformations need to be applied to the code, a falsy value otherwise\n * @param transformer {Function(code, filePath)} a function called with the original code and the associated path of the file\n *  from where the code was loaded. Should return the transformed code.\n * @param options {Object} options Optional.\n * @param {Boolean} [options.verbose] write a line to standard error every time the transformer is called\n * @param {Function} [options.postLoadHook] a function that is called with the name of the file being\n *  required. This is called after the require is processed irrespective of whether it was transformed.\n */\nfunction hookRequire(matcher, transformer, options) {\n    options = options || {};\n    var extensions,\n        fn = transformFn(matcher, transformer, options.verbose),\n        postLoadHook = options.postLoadHook &&\n            typeof options.postLoadHook === 'function' ? options.postLoadHook : null;\n\n    extensions = options.extensions || ['.js'];\n\n    extensions.forEach(function(ext){\n        if (!(ext in originalLoaders)) {\n            originalLoaders[ext] = Module._extensions[ext] || Module._extensions['.js'];\n        }\n        Module._extensions[ext] = function (module, filename) {\n            var ret = fn(fs.readFileSync(filename, 'utf8'), filename);\n            if (ret.changed) {\n                module._compile(ret.code, filename);\n            } else {\n                originalLoaders[ext](module, filename);\n            }\n            if (postLoadHook) {\n                postLoadHook(filename);\n            }\n        };\n    });\n}\n/**\n * unhook `require` to restore it to its original state.\n * @method unhookRequire\n * @static\n */\nfunction unhookRequire() {\n    Object.keys(originalLoaders).forEach(function(ext) {\n        Module._extensions[ext] = originalLoaders[ext];\n    });\n}\n/**\n * hooks `vm.createScript` to return transformed code out of which a `Script` object will be created.\n * Exceptions in the transform result in the original code being used instead.\n * @method hookCreateScript\n * @static\n * @param matcher {Function(filePath)} a function that is called with the filename passed to `vm.createScript`\n *  Should return a truthy value when transformations need to be applied to the code, a falsy value otherwise\n * @param transformer {Function(code, filePath)} a function called with the original code and the filename passed to\n *  `vm.createScript`. Should return the transformed code.\n * @param options {Object} options Optional.\n * @param {Boolean} [options.verbose] write a line to standard error every time the transformer is called\n */\nfunction hookCreateScript(matcher, transformer, opts) {\n    opts = opts || {};\n    var fn = transformFn(matcher, transformer, opts.verbose);\n    vm.createScript = function (code, file) {\n        var ret = fn(code, file);\n        return originalCreateScript(ret.code, file);\n    };\n}\n\n/**\n * unhooks vm.createScript, restoring it to its original state.\n * @method unhookCreateScript\n * @static\n */\nfunction unhookCreateScript() {\n    vm.createScript = originalCreateScript;\n}\n\n\n/**\n * hooks `vm.runInThisContext` to return transformed code.\n * @method hookRunInThisContext\n * @static\n * @param matcher {Function(filePath)} a function that is called with the filename passed to `vm.createScript`\n *  Should return a truthy value when transformations need to be applied to the code, a falsy value otherwise\n * @param transformer {Function(code, filePath)} a function called with the original code and the filename passed to\n *  `vm.createScript`. Should return the transformed code.\n * @param options {Object} options Optional.\n * @param {Boolean} [options.verbose] write a line to standard error every time the transformer is called\n */\nfunction hookRunInThisContext(matcher, transformer, opts) {\n    opts = opts || {};\n    var fn = transformFn(matcher, transformer, opts.verbose);\n    vm.runInThisContext = function (code, file) {\n        var ret = fn(code, file);\n        return originalRunInThisContext(ret.code, file);\n    };\n}\n\n/**\n * unhooks vm.runInThisContext, restoring it to its original state.\n * @method unhookRunInThisContext\n * @static\n */\nfunction unhookRunInThisContext() {\n    vm.runInThisContext = originalRunInThisContext;\n}\n\n\nmodule.exports = {\n    hookRequire: hookRequire,\n    unhookRequire: unhookRequire,\n    hookCreateScript: hookCreateScript,\n    unhookCreateScript: unhookCreateScript,\n    hookRunInThisContext : hookRunInThisContext,\n    unhookRunInThisContext : unhookRunInThisContext,\n    unloadRequireCache: unloadRequireCache\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/reporter.js":"/*\n Copyright (c) 2014, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar Report = require('./report'),\n    configuration = require('./config'),\n    inputError = require('./util/input-error');\n\n/**\n * convenience mechanism to write one or more reports ensuring that config\n * options are respected.\n * Usage\n * -----\n *\n *      var fs = require('fs'),\n *          reporter = new require('istanbul').Reporter(),\n *          collector = new require('istanbul').Collector(),\n *          sync = true;\n *\n *      collector.add(JSON.parse(fs.readFileSync('coverage.json', 'utf8')));\n *      reporter.add('lcovonly');\n *      reporter.addAll(['clover', 'cobertura']);\n *      reporter.write(collector, sync, function () { console.log('done'); });\n *\n * @class Reporter\n * @param {Configuration} cfg  the config object, a falsy value will load the\n *  default configuration instead\n * @param {String} dir  the directory in which to write the reports, may be falsy\n *  to use config or global defaults\n * @constructor\n * @module main\n */\nfunction Reporter(cfg, dir) {\n    this.config = cfg || configuration.loadFile();\n    this.dir = dir || this.config.reporting.dir();\n    this.reports = {};\n}\n\nReporter.prototype = {\n    /**\n     * adds a report to be generated. Must be one of the entries returned\n     * by `Report.getReportList()`\n     * @method add\n     * @param {String} fmt the format of the report to generate\n     */\n    add: function (fmt) {\n        if (this.reports[fmt]) { // already added\n            return;\n        }\n        var config = this.config,\n            rptConfig = config.reporting.reportConfig()[fmt] || {};\n        rptConfig.verbose = config.verbose;\n        rptConfig.dir = this.dir;\n        rptConfig.watermarks = config.reporting.watermarks();\n        try {\n            this.reports[fmt] = Report.create(fmt, rptConfig);\n        } catch (ex) {\n            throw inputError.create('Invalid report format [' + fmt + ']');\n        }\n    },\n    /**\n     * adds an array of report formats to be generated\n     * @method addAll\n     * @param {Array} fmts an array of report formats\n     */\n    addAll: function (fmts) {\n        var that = this;\n        fmts.forEach(function (f) {\n            that.add(f);\n        });\n    },\n    /**\n     * writes all reports added and calls the callback when done\n     * @method write\n     * @param {Collector} collector the collector having the coverage data\n     * @param {Boolean} sync true to write reports synchronously\n     * @param {Function} callback the callback to call when done. When `sync`\n     * is true, the callback will be called in the same process tick.\n     */\n    write: function (collector, sync, callback) {\n        var reports = this.reports,\n            verbose = this.config.verbose,\n            handler = this.handleDone.bind(this, callback);\n\n        this.inProgress = Object.keys(reports).length;\n\n        Object.keys(reports).forEach(function (name) {\n            var report = reports[name];\n            if (verbose) {\n                console.error('Write report: ' + name);\n            }\n            report.on('done', handler);\n            report.writeReport(collector, sync);\n        });\n    },\n    /*\n     * handles listening on all reports to be completed before calling the callback\n     * @method handleDone\n     * @private\n     * @param {Function} callback the callback to call when all reports are\n     * written\n     */\n    handleDone: function (callback) {\n        this.inProgress -= 1;\n        if (this.inProgress === 0) {\n            return callback();\n        }\n    }\n};\n\nmodule.exports = Reporter;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/command/help.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar Command = require('./index.js'),\n    util = require('util'),\n    formatOption = require('../util/help-formatter').formatOption,\n    VERSION = require('../../index').VERSION,\n    configuration = require('../config'),\n    yaml = require('js-yaml'),\n    formatPara = require('../util/help-formatter').formatPara;\n\nfunction showConfigHelp(toolName) {\n\n    console.error('\\nConfiguring ' + toolName);\n    console.error('====================');\n    console.error('\\n' +\n        formatPara(toolName + ' can be configured globally using a .istanbul.yml YAML file ' +\n            'at the root of your source tree. Every command also accepts a --config=<config-file> argument to ' +\n            'customize its location per command. The alternate config file can be in YAML, JSON or node.js ' +\n            '(exporting the config object).'));\n    console.error('\\n' +\n        formatPara('The config file currently has four sections for instrumentation, reporting, hooks, ' +\n            'and checking. Note that certain commands (like `cover`) use information from multiple sections.'));\n    console.error('\\n' +\n        formatPara('Keys in the config file usually correspond to command line parameters with the same name. ' +\n            'The verbose option for every command shows you the exact configuration used. See the api ' +\n            'docs for an explanation of each key.'));\n\n    console.error('\\n' +\n        formatPara('You only need to specify the keys that you want to override. Your overrides will be merged ' +\n            'with the default config.'));\n    console.error('\\nThe default configuration is as follows:\\n');\n    console.error(yaml.safeDump(configuration.defaultConfig(), { indent: 4, flowLevel: 3 }));\n    console.error('\\n' +\n        formatPara('The `watermarks` section does not have a command line equivalent. It allows you to set up ' +\n            'low and high watermark percentages for reporting. These are honored by all reporters that colorize ' +\n            'their output based on low/ medium/ high coverage.'));\n    console.error('\\n' +\n        formatPara('The `reportConfig` section allows you to configure each report format independently ' +\n            'and has no command-line equivalent either.'));\n    console.error('\\n' +\n        formatPara('The `check` section configures minimum threshold enforcement for coverage results. ' +\n            '`global` applies to all files together and `each` on a per-file basis. A list of files can ' +\n            'be excluded from enforcement relative to root via the `exclude` property.'));\n    console.error('');\n}\n\nfunction HelpCommand() {\n    Command.call(this);\n}\n\nHelpCommand.TYPE = 'help';\nutil.inherits(HelpCommand, Command);\n\nCommand.mix(HelpCommand, {\n    synopsis: function () {\n        return \"shows help\";\n    },\n\n    usage: function () {\n\n        console.error('\\nUsage: ' + this.toolName() + ' ' + this.type() + ' config | <command>\\n');\n        console.error('`config` provides help with istanbul configuration\\n');\n        console.error('Available commands are:\\n');\n\n        var commandObj;\n        Command.getCommandList().forEach(function (cmd) {\n            commandObj = Command.create(cmd);\n            console.error(formatOption(cmd, commandObj.synopsis()));\n            console.error(\"\\n\");\n        });\n        console.error(\"Command names can be abbreviated as long as the abbreviation is unambiguous\");\n        console.error(this.toolName() + ' version:' + VERSION);\n        console.error(\"\\n\");\n    },\n    run: function (args, callback) {\n        var command;\n        if (args.length === 0) {\n            this.usage();\n        } else {\n            if (args[0] === 'config') {\n                showConfigHelp(this.toolName());\n            } else {\n                try {\n                    command = Command.create(args[0]);\n                    command.usage('istanbul', Command.resolveCommandName(args[0]));\n                } catch (ex) {\n                    console.error('Invalid command: ' + args[0]);\n                    this.usage();\n                }\n            }\n        }\n        return callback();\n    }\n});\n\n\nmodule.exports = HelpCommand;\n\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/command/instrument.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar path = require('path'),\n    mkdirp = require('mkdirp'),\n    once = require('once'),\n    async = require('async'),\n    fs = require('fs'),\n    filesFor = require('../util/file-matcher').filesFor,\n    nopt = require('nopt'),\n    Instrumenter = require('../instrumenter'),\n    inputError = require('../util/input-error'),\n    formatOption = require('../util/help-formatter').formatOption,\n    util = require('util'),\n    Command = require('./index'),\n    Collector = require('../collector'),\n    configuration = require('../config'),\n    verbose;\n\n\n/*\n * Chunk file size to use when reading non JavaScript files in memory\n * and copying them over when using complete-copy flag.\n */\nvar READ_FILE_CHUNK_SIZE = 64 * 1024;\n\nfunction BaselineCollector(instrumenter) {\n    this.instrumenter = instrumenter;\n    this.collector = new Collector();\n    this.instrument = instrumenter.instrument.bind(this.instrumenter);\n\n    var origInstrumentSync = instrumenter.instrumentSync;\n    this.instrumentSync = function () {\n        var args = Array.prototype.slice.call(arguments),\n            ret = origInstrumentSync.apply(this.instrumenter, args),\n            baseline = this.instrumenter.lastFileCoverage(),\n            coverage = {};\n        coverage[baseline.path] = baseline;\n        this.collector.add(coverage);\n        return ret;\n    };\n    //monkey patch the instrumenter to call our version instead\n    instrumenter.instrumentSync = this.instrumentSync.bind(this);\n}\n\nBaselineCollector.prototype = {\n    getCoverage: function () {\n        return this.collector.getFinalCoverage();\n    }\n};\n\n\nfunction processFiles(instrumenter, inputDir, outputDir, relativeNames, extensions) {\n    var processor = function (name, callback) {\n            var inputFile = path.resolve(inputDir, name),\n                outputFile = path.resolve(outputDir, name),\n                inputFileExtenstion = path.extname(inputFile),\n                isJavaScriptFile = extensions.indexOf(inputFileExtenstion) > -1,\n                oDir = path.dirname(outputFile),\n                readStream, writeStream;\n\n            callback = once(callback);\n            mkdirp.sync(oDir);\n\n            if (fs.statSync(inputFile).isDirectory()) {\n                return callback(null, name);\n            }\n\n            if (isJavaScriptFile) {\n                fs.readFile(inputFile, 'utf8', function (err, data) {\n                    if (err) { return callback(err, name); }\n                    instrumenter.instrument(data, inputFile, function (iErr, instrumented) {\n                        if (iErr) { return callback(iErr, name); }\n                        fs.writeFile(outputFile, instrumented, 'utf8', function (err) {\n                            return callback(err, name);\n                        });\n                    });\n                });\n            }\n            else {\n                // non JavaScript file, copy it as is\n                readStream = fs.createReadStream(inputFile, {'bufferSize': READ_FILE_CHUNK_SIZE});\n                writeStream = fs.createWriteStream(outputFile);\n\n                readStream.on('error', callback);\n                writeStream.on('error', callback);\n\n                readStream.pipe(writeStream);\n                readStream.on('end', function() {\n                    callback(null, name);\n                });\n            }\n        },\n        q = async.queue(processor, 10),\n        errors = [],\n        count = 0,\n        startTime = new Date().getTime();\n\n    q.push(relativeNames, function (err, name) {\n        var inputFile, outputFile;\n        if (err) {\n            errors.push({ file: name, error: err.message || err.toString() });\n            inputFile = path.resolve(inputDir, name);\n            outputFile = path.resolve(outputDir, name);\n            fs.writeFileSync(outputFile, fs.readFileSync(inputFile));\n        }\n        if (verbose) {\n            console.log('Processed: ' + name);\n        } else {\n            if (count % 100 === 0) { process.stdout.write('.'); }\n        }\n        count += 1;\n    });\n\n    q.drain = function () {\n        var endTime = new Date().getTime();\n        console.log('\\nProcessed [' + count + '] files in ' + Math.floor((endTime - startTime) / 1000) + ' secs');\n        if (errors.length > 0) {\n            console.log('The following ' + errors.length + ' file(s) had errors and were copied as-is');\n            console.log(errors);\n        }\n    };\n}\n\n\nfunction InstrumentCommand() {\n    Command.call(this);\n}\n\nInstrumentCommand.TYPE = 'instrument';\nutil.inherits(InstrumentCommand, Command);\n\nCommand.mix(InstrumentCommand, {\n    synopsis: function synopsis() {\n        return \"instruments a file or a directory tree and writes the instrumented code to the desired output location\";\n    },\n\n    usage: function () {\n        console.error('\\nUsage: ' + this.toolName() + ' ' + this.type() + ' <options> <file-or-directory>\\n\\nOptions are:\\n\\n' +\n            [\n                formatOption('--config <path-to-config>', 'the configuration file to use, defaults to .istanbul.yml'),\n                formatOption('--output <file-or-dir>', 'The output file or directory. This is required when the input is a directory, ' +\n                    'defaults to standard output when input is a file'),\n                formatOption('-x <exclude-pattern> [-x <exclude-pattern>]', 'one or more glob patterns (e.g. \"**/vendor/**\" to ignore all files ' +\n                    'under a vendor directory). Also see the --default-excludes option'),\n                formatOption('--variable <global-coverage-variable-name>', 'change the variable name of the global coverage variable from the ' +\n                    'default value of `__coverage__` to something else'),\n                formatOption('--embed-source', 'embed source code into the coverage object, defaults to false'),\n                formatOption('--[no-]compact', 'produce [non]compact output, defaults to compact'),\n                formatOption('--[no-]preserve-comments', 'remove / preserve comments in the output, defaults to false'),\n                formatOption('--[no-]complete-copy', 'also copy non-javascript files to the ouput directory as is, defaults to false'),\n                formatOption('--save-baseline', 'produce a baseline coverage.json file out of all files instrumented'),\n                formatOption('--baseline-file <file>', 'filename of baseline file, defaults to coverage/coverage-baseline.json'),\n                formatOption('--es-modules', 'source code uses es import/export module syntax')\n            ].join('\\n\\n') + '\\n');\n        console.error('\\n');\n    },\n\n    run: function (args, callback) {\n\n        var template = {\n                config: path,\n                output: path,\n                x: [Array, String],\n                variable: String,\n                compact: Boolean,\n                'complete-copy': Boolean,\n                verbose: Boolean,\n                'save-baseline': Boolean,\n                'baseline-file': path,\n                'embed-source': Boolean,\n                'preserve-comments': Boolean,\n                'es-modules': Boolean\n            },\n            opts = nopt(template, { v : '--verbose' }, args, 0),\n            overrides = {\n                verbose: opts.verbose,\n                instrumentation: {\n                    variable: opts.variable,\n                    compact: opts.compact,\n                    'embed-source': opts['embed-source'],\n                    'preserve-comments': opts['preserve-comments'],\n                    excludes: opts.x,\n                    'complete-copy': opts['complete-copy'],\n                    'save-baseline': opts['save-baseline'],\n                    'baseline-file': opts['baseline-file'],\n                    'es-modules': opts['es-modules']\n                }\n            },\n            config = configuration.loadFile(opts.config, overrides),\n            iOpts = config.instrumentation,\n            cmdArgs = opts.argv.remain,\n            file,\n            stats,\n            stream,\n            includes,\n            instrumenter,\n            needBaseline = iOpts.saveBaseline(),\n            baselineFile = path.resolve(iOpts.baselineFile()),\n            output = opts.output;\n\n        verbose = config.verbose;\n        if (cmdArgs.length !== 1) {\n            return callback(inputError.create('Need exactly one filename/ dirname argument for the instrument command!'));\n        }\n\n        if (iOpts.completeCopy()) {\n            includes = ['**/*'];\n        }\n        else {\n            includes = iOpts.extensions().map(function(ext) {\n                return '**/*' + ext;\n            });\n        }\n\n        instrumenter = new Instrumenter({\n            coverageVariable: iOpts.variable(),\n            embedSource: iOpts.embedSource(),\n            noCompact: !iOpts.compact(),\n            preserveComments: iOpts.preserveComments(),\n            esModules: iOpts.esModules()\n        });\n\n        if (needBaseline) {\n            mkdirp.sync(path.dirname(baselineFile));\n            instrumenter = new BaselineCollector(instrumenter);\n            process.on('exit', function () {\n                console.log('Saving baseline coverage at: ' + baselineFile);\n                fs.writeFileSync(baselineFile, JSON.stringify(instrumenter.getCoverage()), 'utf8');\n            });\n        }\n\n        file = path.resolve(cmdArgs[0]);\n        stats = fs.statSync(file);\n        if (stats.isDirectory()) {\n            if (!output) { return callback(inputError.create('Need an output directory [-o <dir>] when input is a directory!')); }\n            if (output === file) { return callback(inputError.create('Cannot instrument into the same directory/ file as input!')); }\n            mkdirp.sync(output);\n            filesFor({\n                root: file,\n                includes: includes,\n                excludes: opts.x || iOpts.excludes(false), // backwards-compat, *sigh*\n                relative: true\n            }, function (err, files) {\n                if (err) { return callback(err); }\n                processFiles(instrumenter, file, output, files, iOpts.extensions());\n            });\n        } else {\n            if (output) {\n                stream = fs.createWriteStream(output);\n            } else {\n                stream = process.stdout;\n            }\n            stream.write(instrumenter.instrumentSync(fs.readFileSync(file, 'utf8'), file));\n            if (stream !== process.stdout) {\n                stream.end();\n            }\n        }\n    }\n});\n\nmodule.exports = InstrumentCommand;\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/command/report.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar nopt = require('nopt'),\n    Report = require('../report'),\n    Reporter = require('../reporter'),\n    path = require('path'),\n    fs = require('fs'),\n    Collector = require('../collector'),\n    helpFormatter = require('../util/help-formatter'),\n    formatOption = helpFormatter.formatOption,\n    formatPara = helpFormatter.formatPara,\n    filesFor = require('../util/file-matcher').filesFor,\n    util = require('util'),\n    Command = require('./index'),\n    configuration = require('../config');\n\nfunction ReportCommand() {\n    Command.call(this);\n}\n\nReportCommand.TYPE = 'report';\nutil.inherits(ReportCommand, Command);\n\nfunction printDeprecationMessage(pat, fmt) {\n    console.error('**********************************************************************');\n    console.error('DEPRECATION WARNING! You are probably using the old format of the report command');\n    console.error('This will stop working soon, see `istanbul help report` for the new command format');\n    console.error('Assuming you meant: istanbul report --include=' + pat + ' ' + fmt);\n    console.error('**********************************************************************');\n}\n\nCommand.mix(ReportCommand, {\n    synopsis: function () {\n        return \"writes reports for coverage JSON objects produced in a previous run\";\n    },\n\n    usage: function () {\n        console.error('\\nUsage: ' + this.toolName() + ' ' + this.type() + ' <options> [ <format> ... ]\\n\\nOptions are:\\n\\n' +\n            [\n                formatOption('--config <path-to-config>', 'the configuration file to use, defaults to .istanbul.yml'),\n                formatOption('--root <input-directory>', 'The input root directory for finding coverage files'),\n                formatOption('--dir <report-directory>', 'The output directory where files will be written. This defaults to ./coverage/'),\n                formatOption('--include <glob>', 'The glob pattern to select one or more coverage files, defaults to **/coverage*.json'),\n                formatOption('--verbose, -v', 'verbose mode')\n            ].join('\\n\\n'));\n\n        console.error('\\n');\n        console.error('<format> is one of ');\n        Report.getReportList().forEach(function (name) {\n           console.error(formatOption(name, Report.create(name).synopsis()));\n        });\n        console.error(\"\");\n        console.error(formatPara([\n            'Default format is lcov unless otherwise specified in the config file.',\n            'In addition you can tweak the file names for various reports using the config file.',\n            'Type `istanbul help config` to see what can be tweaked.'\n        ].join(' ')));\n        console.error('\\n');\n    },\n\n    run: function (args, callback) {\n\n        var template = {\n                config: path,\n                root: path,\n                dir: path,\n                include: String,\n                verbose: Boolean\n            },\n            opts = nopt(template, { v : '--verbose' }, args, 0),\n            includePattern = opts.include || '**/coverage*.json',\n            root,\n            collector = new Collector(),\n            config = configuration.loadFile(opts.config, {\n                verbose: opts.verbose,\n                reporting: {\n                    dir: opts.dir\n                }\n            }),\n            formats = opts.argv.remain,\n            reporter = new Reporter(config);\n\n        // Start: backward compatible processing\n        if (formats.length === 2 &&\n                Report.getReportList().indexOf(formats[1]) < 0) {\n            includePattern = formats[1];\n            formats = [ formats[0] ];\n            printDeprecationMessage(includePattern, formats[0]);\n        }\n        // End: backward compatible processing\n\n        if (formats.length === 0) {\n            formats = config.reporting.reports();\n        }\n        if (formats.length === 0) {\n            formats = [ 'lcov' ];\n        }\n        reporter.addAll(formats);\n\n        root = opts.root || process.cwd();\n        filesFor({\n            root: root,\n            includes: [ includePattern ]\n        }, function (err, files) {\n            if (err) { throw err; }\n            files.forEach(function (file) {\n                var coverageObject =  JSON.parse(fs.readFileSync(file, 'utf8'));\n                collector.add(coverageObject);\n            });\n            reporter.write(collector, false, function (err) {\n                console.log('Done');\n                return callback(err);\n            });\n        });\n    }\n});\n\nmodule.exports = ReportCommand;\n\n\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/command/test.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar runWithCover = require('./common/run-with-cover'),\n    util = require('util'),\n    Command = require('./index');\n\nfunction TestCommand() {\n    Command.call(this);\n}\n\nTestCommand.TYPE = 'test';\nutil.inherits(TestCommand, Command);\n\nCommand.mix(TestCommand, {\n    synopsis: function () {\n        return \"cover a node command only when npm_config_coverage is set. Use in an `npm test` script for conditional coverage\";\n    },\n\n    usage: function () {\n        runWithCover.usage(this.toolName(), this.type());\n    },\n\n    run: function (args, callback) {\n        runWithCover.run(args, this.type(), !!process.env.npm_config_coverage, callback);\n    }\n});\n\nmodule.exports = TestCommand;\n","/home/travis/build/npmtest/node-npmtest-istanbul/istanbul/lib/util/yui-load-hook.js":"/*\n Copyright (c) 2012, Yahoo! Inc.  All rights reserved.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n//EXPERIMENTAL code: do not rely on this in anyway until the docs say it is allowed\n\nvar path = require('path'),\n    yuiRegexp = /yui-nodejs\\.js$/;\n\nmodule.exports = function (matchFn, transformFn, verbose) {\n    return function (file) {\n        if (!file.match(yuiRegexp)) {\n            return;\n        }\n        var YMain = require(file),\n            YUI,\n            loaderFn,\n            origGet;\n\n        if (YMain.YUI) {\n            YUI = YMain.YUI;\n            loaderFn = YUI.Env && YUI.Env.mods && YUI.Env.mods['loader-base'] ? YUI.Env.mods['loader-base'].fn : null;\n            if (!loaderFn) { return; }\n            if (verbose) { console.log('Applying YUI load post-hook'); }\n            YUI.Env.mods['loader-base'].fn = function (Y) {\n                loaderFn.call(null, Y);\n                origGet = Y.Get._exec;\n                Y.Get._exec = function (data, url, cb) {\n                    if (matchFn(url) || matchFn(path.resolve(url))) { //allow for relative paths as well\n                        if (verbose) {\n                            console.log('Transforming [' + url + ']');\n                        }\n                        try {\n                            data = transformFn(data, url);\n                        } catch (ex) {\n                            console.error('Error transforming: ' + url + ' return original code');\n                            console.error(ex.message || ex);\n                            if (ex.stack) { console.error(ex.stack); }\n                        }\n                    }\n                    return origGet.call(Y, data, url, cb);\n                };\n                return Y;\n            };\n        }\n    };\n};\n\n"}